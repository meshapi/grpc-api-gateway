{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>The gRPC API Gateway is a plugin for the protocol buffers protoc that reads protocol buffer and gRPC service definitions to generate a reverse-proxy HTTP server handler in Go. This handler is compatible with the standard library's http package and enables the translation of HTTP API calls into gRPC.</p> <p></p>"},{"location":"#overview","title":"Overview","text":"<p>The gRPC Gateway is a versatile tool that bridges the gap between gRPC services and HTTP-based APIs, including RESTful or WebSockets. It enables clients that do not support gRPC natively to communicate with gRPC servers using familiar HTTP and JSON formats. This capability is particularly valuable for integrating gRPC services into existing systems or for clients operating in environments where gRPC is not directly supported.</p> <p>The gateway seamlessly translates incoming HTTP/JSON requests into corresponding gRPC calls, facilitating the integration of gRPC services into a wide range of applications. It offers additional functionalities such as request/response transformation, JSON request validation, and customizable error handling, enhancing the flexibility and robustness of the integration process.</p> <p>Additionally, there is a versatile plugin that can generate a corresponding OpenAPI v3.1 document for the resulting HTTP API. However, since OpenAPI is generally meant to capture RESTful APIs, it does not automatically generate documentation for WebSocket bindings.</p> <p>In essence, the gRPC Gateway streamlines the exposure of gRPC services to clients that require HTTP-based interfaces, simplifying the development and deployment of services that cater to diverse client environments. This capability is especially beneficial for clients operating in web browsers, where direct gRPC support may be limited.</p>"},{"location":"#rationale","title":"Rationale","text":"<p>This project aims to implement features that the gRPC Gateway project does not plan to cover. These include bidirectional streaming APIs, dynamic reverse proxy capabilities, and full support for the OpenAPI v3.1 specification. These additions enhance the versatility and power of the gRPC API Gateway, providing users with a comprehensive solution for their API gateway needs.</p> <p> Inspiration and Gratitude: This project is deeply inspired by the widely recognized gRPC Gateway. Building upon its established and stable implementation has enabled rapid development of similar features, allowing us to focus on introducing new functionality. We extend our sincere thanks to the creators of the gRPC Gateway for laying the foundation.</p>"},{"location":"#key-differences","title":"Key Differences","text":"<p>The differences can be summarized into the following points:</p>"},{"location":"#streaming-apis","title":"Streaming APIs","text":"<p>This plugin offers broader support for streaming APIs, including WebSockets, Server-Sent Events (SSE), and Chunked Transfer for all directions, including long-lived bidirectional methods.</p>"},{"location":"#openapi-v31-support","title":"OpenAPI v3.1 Support","text":"<p>A primary goal of this project was to support the OpenAPI v3.1 specification. This includes finer control over field nullability and necessity (required or not). This precision in OpenAPI specification allows for more accurate generation of client code, such as JavaScript/TypeScript.</p>"},{"location":"#improved-configuration-format","title":"Improved Configuration Format","text":"<p>Significant effort has been invested in simplifying and enhancing the configuration format. Configurations can now be spread across multiple files, allowing for different configuration flavors (e.g., in proto files vs. standalone files) and reducing repetition through inheritance in configurations. Additionally, there is finer control over the presence and naming of query parameters and path parameters.</p>"},{"location":"#gateway-errors","title":"Gateway Errors","text":"<p>Most errors encountered by the gateway, such as missing parameters, incorrect types, and unsupported streaming methods, are exported error types so the error handler has the opportunity to handle each scenario differently.</p>"},{"location":"#dynamic-reverse-proxy-in-progress","title":"Dynamic Reverse Proxy (In Progress)","text":"<p>While generating Go code for the reverse proxy already facilitates providing an HTTP interface to a gRPC API, applications written in languages other than Go require an additional step of installing Go and compiling the generated code.</p> <p>This project aims to provide a solution by allowing users to embed or install a binary version of the gRPC API Gateway, preserving the same configuration file format. This will enable quick setup of a reverse proxy for a gRPC API and generation of OpenAPI documentation.</p> <p>Initial language support will include Python, Rust, Node.js, C, and C++ with embedded support.</p>"},{"location":"installation/","title":"Installation","text":"<p>You can directly download the binaries from the Releases page, which also includes the proto files containing the annotations.</p> <p>Additionally, you can find the binaries in the package repositories listed below:</p>"},{"location":"installation/#arch-linux","title":"Arch Linux","text":"<p>This plug-in is not part of the official repository, but you can use a package from the user repository (AUR):</p> <p>protoc-gen-grpc-api-gateway-bin</p> <p>To install it using <code>makepkg</code>, follow these steps:</p> <pre><code>$ git clone https://aur.archlinux.org/protoc-gen-grpc-api-gateway-bin.git\n$ cd protoc-gen-grpc-api-gateway-bin &amp;&amp; makepkg -si\n</code></pre>"},{"location":"installation/#alpine-linux","title":"Alpine Linux","text":"<p>This is an ongoing effort and should be available soon. In the meantime, you can download the binaries from the Releases page or install from source.</p>"},{"location":"installation/#install-from-source","title":"Install from Source","text":"<p>If binaries are not available for your operating system or architecture, you can install from the source using Go:</p> <pre><code>$ go install github.com/meshapi/grpc-api-gateway/codegen/cmd/protoc-gen-openapiv3@&lt;version&gt;\n$ go install github.com/meshapi/grpc-api-gateway/codegen/cmd/protoc-gen-grpc-api-gateway@&lt;version&gt;\n</code></pre> <p>To retrieve the latest version, replace <code>&lt;version&gt;</code> with <code>latest</code>.</p>"},{"location":"installation/#docker","title":"Docker","text":"<p>To install this tool inside a Docker container, you can use <code>wget</code> or <code>curl</code> to download the binaries for your intended architecture. Refer to the Releases page for more details.</p>"},{"location":"quickstart/generation/","title":"Create a Simple Service","text":"<p>In this guide, we will generate and implement a simple gRPC service. In the following section, we will add the reverse proxy and the HTTP bindings.</p>"},{"location":"quickstart/generation/#echo-service","title":"Echo Service","text":"<p>To get started, let's create the following proto file.</p> echo_service.proto<pre><code>syntax = \"proto3\";\n\npackage echo;\n\noption go_package = \"demo/echo\";\n\nmessage EchoRequest {\n    string text = 1;\n    bool capitalize = 2;\n}\n\nmessage EchoResponse {\n    string text = 1;\n}\n\nservice EchoService {\n    // Echo returns the received text and make it louder too!\n    rpc Echo(EchoRequest) returns (EchoResponse);\n}\n</code></pre>"},{"location":"quickstart/generation/#code-generation","title":"Code Generation","text":"<p>Buf is a tool that simplifies the development and consumption of Protobuf APIs. One of Buf's features is managing dependencies and building proto files.</p> <p>If you decide to use Buf, follow the instructions below or switch to the <code>protoc</code> tab for instructions using protoc.</p> Using BufUsing protoc <p>Let's create a buf.gen.yaml with the following content:</p> buf.gen.yaml<pre><code>version: v1\nplugins:\n  - out: gen\n    name: go\n\n  - out: gen\n    name: go-grpc\n\n  - out: gen\n    name: grpc-api-gateway\n\n  - out: gen\n    name: openapiv3\n</code></pre> <p>Now generate the artifacts using:</p> <pre><code>$ buf generate\n</code></pre> <p>You should see the generated files inside the <code>gen</code> directory.</p> <pre><code>$ protoc \\\n    --go_out=gen \\\n    --go-grpc_out=gen \\\n    --grpc-api-gateway_out=gen \\\n    --openapiv3_out=gen \\\n    echo_service.proto\n</code></pre> <pre><code>You should see the generated files inside the `gen` directory.\n</code></pre> <p>Tip</p> <p>It might be a good idea to use <code>Makefile</code>s to avoid typing a long command repeatedly.</p>"},{"location":"quickstart/generation/#implementing-the-service","title":"Implementing the Service","text":"<p>First, let's set up our Go module:</p> <pre><code>$ go mod init demo\n</code></pre> <p>The following <code>main.go</code> file implements the Echo service and starts a gRPC server on port <code>40000</code>:</p> main.go<pre><code>package main\n\nimport (\n    \"context\"\n    \"demo/gen/demo/echo\"\n    \"log\"\n    \"net\"\n    \"strings\"\n\n    \"google.golang.org/grpc\"\n)\n\ntype Service struct {\n    echo.UnimplementedEchoServiceServer\n}\n\nfunc (Service) Echo(\n    ctx context.Context,\n    req *echo.EchoRequest) (*echo.EchoResponse, error) {\n\n    response := &amp;echo.EchoResponse{\n        Text: req.Text,\n    }\n\n    if req.Capitalize {\n        response.Text = strings.ToUpper(response.Text)\n    }\n\n    return response, nil\n}\n\nfunc main() {\n    listener, err := net.Listen(\"tcp\", \":40000\")\n    if err != nil {\n        log.Fatalf(\"failed to listen: %s\", err)\n    }\n\n    server := grpc.NewServer()\n    echo.RegisterEchoServiceServer(server, Service{})\n\n    if err := server.Serve(listener); err != nil {\n        log.Fatalf(\"gRPC server failed: %v\", err)\n    }\n}\n</code></pre>"},{"location":"quickstart/generation/#running-the-service","title":"Running the Service","text":"<p>Let's run it and ensure everything works correctly:</p> <pre><code>$ go mod tidy\n$ go run .\n</code></pre> <p>If everything looks good, let's proceed to the next part and add the HTTP bindings!</p>"},{"location":"quickstart/http_binding/","title":"Add HTTP Bindings","text":""},{"location":"quickstart/http_binding/#define-http-bindings","title":"Define HTTP Bindings","text":"<p>To define the HTTP bindings for our gRPC service, we need to map gRPC methods to HTTP endpoints.</p> <p>This can be achieved either via gRPC API Gateway proto extensions or through a configuration file.</p> <p>Configuration loading can be highly customized. Refer to Configuration for more details. By default, for any proto file <code>file.proto</code>, the files <code>file_gateway.yaml</code>, <code>file_gateway.yml</code>, and <code>file_gateway.json</code> will be tried in that order. If any file is available, it will be used and the search will be stopped.</p> <p>Choose the method that works best for you and your project. This document provides guidelines for both methods.</p> <p>Info</p> <p>You can use the <code>generate_unbound_methods</code> option to automatically define HTTP bindings for gRPC methods that do not already have a defined binding. The path will be in the form of <code>/proto.package.Service/Method</code> and the HTTP method will be <code>POST</code>.</p> <p>Let's create two HTTP endpoints for the <code>Echo</code> method, one using <code>GET</code> and one using <code>POST</code>, using your preferred method: either configuration files or proto annotations.</p>"},{"location":"quickstart/http_binding/#1-using-configuration-files","title":"1. Using Configuration Files","text":"<p>Create a new file with the pattern <code>&lt;proto-filename&gt;_gateway.yaml</code>. Since we used <code>echo_service.proto</code> in this demo, we will create <code>echo_service_gateway.yaml</code> with the following content:</p> echo_service_gateway.yaml<pre><code>gateway:\n  endpoints:\n    - selector: '~.EchoService.Echo' # (1)!\n      get: '/echo/{text}' # (2)!\n      additional_bindings: # (3)!\n        - post: '/echo'\n          body: '*' # (4)!\n</code></pre> <ol> <li><code>selector</code> is the dot-separated path to the service method. <code>echo.EchoService.Echo</code> is the full path. <code>~</code> gets substituted with the proto package from the related proto file and can be used to shorten the selector.</li> <li>This line specifies that the HTTP method is <code>GET</code> and the route is <code>/echo/{text}</code>, where <code>text</code> is a path to a field in the request proto message.</li> <li>Used to specify additional HTTP endpoint bindings.</li> <li><code>body</code> (default: <code>null</code>) specifies which fields in the proto request message should be read from the HTTP body. In this case, <code>*</code> indicates that all fields in the proto message should be read from the HTTP body.</li> </ol> <p>Tip</p> <p>If you choose to work with configuration files, consider installing a YAML or JSON extension for your editor. Files named according to the pattern <code>*_gateway.[yml|yaml|json]</code> utilize the API Gateway's configuration schema, providing auto-completion and in-editor documentation features.</p>"},{"location":"quickstart/http_binding/#2-using-proto-extensions","title":"2. Using Proto Extensions","text":"<p>To use proto extensions, first download and import the gRPC API Gateway annotations.</p> Using BufUsing Protoc <p>Create a file named <code>buf.yaml</code> with the following content:</p> buf.yaml<pre><code>version: v1\ndeps:\n  - \"buf.build/meshapi/grpc-api-gateway\"\n</code></pre> <p>Download the dependencies using:</p> <pre><code>$ buf mod update\n</code></pre> <p>Download the proto files from the <code>api/meshapi</code> directory in the gRPC API Gateway git repository to a local directory named <code>meshapi</code>.</p> <p>Modify your existing proto file with the following additions:</p> echo_service.proto<pre><code>syntax = \"proto3\";\n\npackage echo;\n\nimport \"meshapi/gateway/annotations.proto\"; //(1)!\n\noption go_package = \"demo/echo\";\n\nmessage EchoRequest {\n  string text = 1;\n  bool capitalize = 2;\n}\n\nmessage EchoResponse {\n    string text = 1;\n}\n\nservice EchoService {\n    // Echo returns the received text and makes it louder too!\n    rpc Echo(EchoRequest) returns (EchoResponse) {\n        option (meshapi.gateway.http) = {\n            get: '/echo/{text}' //(2)!\n            additional_bindings: [ //(3)!\n              {\n                post: '/echo',\n                body: '*' //(4)!\n              }\n            ]\n        };\n    };\n}\n</code></pre> <ol> <li>This line imports the gRPC API Gateway proto annotations.</li> <li>This line specifies that the HTTP method is <code>GET</code> and the route is <code>/echo/{text}</code>, where <code>text</code> is a path to a field in the request proto message.</li> <li>Used to specify additional HTTP endpoint bindings.</li> <li><code>body</code> (default: <code>null</code>) specifies which fields in the proto request message should be read from the HTTP body. In this case, <code>*</code> indicates that all fields in the proto message should be read from the HTTP body.</li> </ol>"},{"location":"quickstart/http_binding/#add-http-server","title":"Add HTTP Server","text":"<p>Now that we have defined HTTP bindings, we need to regenerate the gateway code.</p> Using BufUsing Protoc <pre><code>$ buf generate\n</code></pre> <pre><code>$ protoc \\\n    --go_out=gen \\\n    --go-grpc_out=gen \\\n    --grpc-api-gateway_out=gen \\\n    --openapiv3_out=gen \\\n    echo_service.proto\n</code></pre> <p>Using either method, you should now see a new file named <code>echo_service.pb.rgw.go</code>.</p> <p>Next, get the <code>meshapi/grpc-api-gateway</code> module as it contains necessary types for our HTTP server:</p> <pre><code>$ go get github.com/meshapi/grpc-api-gateway\n</code></pre> <p>Finally, update <code>main.go</code> to add the HTTP server:</p> main.go<pre><code>package main\n\nimport (\n    \"context\"\n    \"demo/gen/demo/echo\"\n    \"log\"\n    \"net\"\n    \"strings\"\n\n    \"github.com/meshapi/grpc-api-gateway/gateway\"\n    \"google.golang.org/grpc\"\n    \"google.golang.org/grpc/credentials/insecure\"\n)\n\n// ... removed service implementation for brevity.\n\nfunc main() {\n    listener, err := net.Listen(\"tcp\", \":40000\")\n    if err != nil {\n        log.Fatalf(\"failed to listen: %s\", err)\n    }\n\n    gateway := gateway.NewServeMux()\n\n    connection, err := grpc.NewClient( //(1)!\n        \":40000\",\n        grpc.WithTransportCredentials(insecure.NewCredentials()))\n    if err != nil {\n        log.Fatalf(\"could not dial gRPC server: %v\", err)\n    }\n\n    server := grpc.NewServer()\n    echo.RegisterEchoServiceServer(server, Service{})\n    echo.RegisterEchoServiceHandler(context.Background(), gateway, connection) //(2)!\n\n    go func() {\n        log.Fatalln(http.ListenAndServe(\"0.0.0.0:4000\", gateway))\n    }()\n\n    if err := server.Serve(listener); err != nil {\n        log.Fatalf(\"gRPC server failed: %v\", err)\n    }\n}\n</code></pre> <ol> <li>We create a gRPC connection to our own gRPC server. gRPC API Gateway uses this connection to communicate with our gRPC services.</li> <li><code>RegisterEchoServiceHandler</code> is a generated function that registers the <code>EchoService</code> to the gateway mux.</li> </ol>"},{"location":"quickstart/http_binding/#see-it-in-action","title":"See it in action","text":"<p>Time to run the code and see it work:</p> <pre><code>$ go run .\n</code></pre> <p>You should be able to send an HTTP request and get a response back:</p> <pre><code>$ curl http://localhost:4000/echo/greetings\n</code></pre> <p>You should get the following response back:</p> <pre><code>{ \"text\": \"greetings\" }\n</code></pre>"},{"location":"quickstart/intro/","title":"Intro","text":"<p>While gRPC API Gateway offers extensive customization and details, this quick step-by-step guide aims to show you the fastest way to generate a reverse proxy for your gRPC service.</p> <p>For a comprehensive reference of all features and configurations, see Reference.</p>"},{"location":"quickstart/intro/#prerequisites","title":"Prerequisites","text":"<p>Before we start coding, ensure that you have installed the gRPC API Gateway protobuf plug-in. Refer to the Installation section for detailed instructions.</p> <p>gRPC API Gateway is a <code>protoc</code> plug-in, similar to the Go code generator. The tool relies on the generated code from both the Go and Go gRPC plug-ins.</p> <p>To install the Go and Go gRPC plug-ins, execute the following commands:</p> <pre><code>$ go install google.golang.org/protobuf/cmd/protoc-gen-go@latest\n$ go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@latest\n</code></pre>"},{"location":"quickstart/openapi/","title":"OpenAPI Documentation","text":"<p>OpenAPI documentation has already been generated for our service. However, we may want to make some modifications to this document.</p> <p>In this section, we will customize our OpenAPI document for the <code>Echo</code> service.</p> <p>Refer to Reference to learn more about all available customizations.</p> <p>Similar to defining HTTP bindings, you can use annotations to directly define options in the proto files or use configuration files.</p> Using configurationsUsing proto extensions echo_service_gateway.yaml<pre><code># ... omitted gateway spec for brevity.\n\nopenapi:\n  document: #(1)!\n    info:\n      title: 'Echo Service'\n      version: 'v0.0.1-alpha1'\n\n  services:\n    - selector: '~.EchoService' #(2)!\n      methods:\n        Echo: #(3)!\n          external_docs:\n            url: 'http://meshapi.github.com/grpc-api-gateway'\n            description: 'Even more documentation!'\n\n  messages:\n    - selector: 'EchoRequest' #(4)!\n      fields:\n        'text':\n          description: \"Text is the input text\"\n          max_length: \"24\"\n</code></pre> <ol> <li><code>document</code> allows you to customize the resulting OpenAPI document for this proto file. We will use it to set    <code>title</code> and <code>version</code> here.</li> <li>Similar to the selector we defined in the HTTP bindings, this is a dotted path to the service and <code>~</code> resolves    to the current proto package.</li> <li>Defining <code>external_docs</code> in the OpenAPI document only for the HTTP endpoints that are bound to the <code>Echo</code> gRPC    method.</li> <li>Similar to the selector we had to define for the service, however here we point to a message to customize    <code>schema</code> for this proto message. In this case, to set custom description and include additional validation    details.</li> </ol> echo_service.proto<pre><code>syntax = \"proto3\";\n\npackage echo;\n\nimport \"meshapi/gateway/annotations.proto\";\n\noption go_package = \"demo/echo\";\noption (meshapi.gateway.openapi_doc) = { //(1)!\n    info: {\n        title: 'Echo Service',\n        version: 'v0.0.1-alpha1'\n    }\n};\n\nmessage EchoRequest {\n    string text = 1 [\n        (meshapi.gateway.openapi_field) = { //(2)!\n            description: 'Text is the input text',\n            max_length: '24'\n        }\n    ];\n    bool capitalize = 2;\n}\n\nmessage EchoResponse {\n    string text = 1;\n}\n\nservice EchoService {\n    // Echo returns the received text and make it louder too!\n    rpc Echo(EchoRequest) returns (EchoResponse) {\n        option (meshapi.gateway.http) = {\n            get: '/echo/{text}'\n            additional_bindings: [\n              {\n                post: '/echo',\n                body: '*'\n              }\n            ]\n        };\n\n        option (meshapi.gateway.openapi_operation) = { //(3)!\n            external_docs: {\n                url: 'http://meshapi.github.com/grpc-api-gateway',\n                description: 'Even more documentation!'\n            }\n        };\n    };\n}\n</code></pre> <ol> <li>This option allows you to customize the resulting OpenAPI document for this proto file. We will use it to set    <code>title</code> and <code>version</code> here.</li> <li>This option allows you to customize the schema generated for this field in the resulting OpenAPI document.    Here we add custom description and extra validation details.</li> <li>This option can be used to customize operation for HTTP endpoints bound to this gRPC method.     Here, defining <code>external_docs</code> in the OpenAPI document only for the HTTP endpoints that are     bound to the <code>Echo</code> gRPC method.</li> </ol> <p>Now you can re-generate using either <code>Buf</code> or <code>protoc</code> directly and notice the changes in the generated OpenAPI file.</p> <p>That's it for our quick guide!</p>"},{"location":"reference/configuration/","title":"Configuration","text":"<p>Significant effort has gone into designing a flexible configuration system with sensible defaults.</p> <p>Both the gRPC API Gateway and OpenAPI v3.1 plug-ins offer extensive customization options through configurations embedded directly in <code>.proto</code> files or through separate configuration files in either <code>YAML</code> or <code>JSON</code> format.</p> <p>Throughout this documentation, you will find examples provided in both proto annotations and <code>YAML</code> configuration file formats.</p>"},{"location":"reference/configuration/#mix-and-match","title":"Mix and Match","text":"<p>You can mix and match these two methods, setting some configurations in <code>proto</code> files and using separate configuration files. However, there are some rules to consider:</p> <p>Note</p> <p>When both proto files and configuration files set an option:</p> <ul> <li> <p>If the value is an object or an array type, the result is a merge of both settings.</p> Example <p>If <code>schema.description</code> is set in a proto file for a message type and <code>schema.summary</code> is set in a configuration file for the same message, the result would contain both <code>summary</code> and <code>description</code>.</p> </li> <li> <p>If the value is a simple type such as string, boolean or number the configuration file takes precedence.</p> Example <p>For instance: if <code>schema.description</code> is set in a proto file for a message type and a configuration file also sets <code>schema.description</code> for the same message, the value from the configuration file is used.</p> </li> </ul>"},{"location":"reference/configuration/#using-proto-annotations","title":"Using proto annotations","text":"<p>When using proto annotations, you will need to import the proto annotations and types for the <code>gRPC API Gateway</code>.</p> <p>Buf is a tool that simplifies the development and consumption of the Protobuf APIs. It manages dependencies and builds proto files efficiently.</p> <p>All proto files and annotations are available on buf.build.</p> <p>If you decide to use Buf, follow the instructions below or you can visit the <code>protoc</code> tab for instructions on using protoc.</p> Using BufUsing protoc <p>Let's create a <code>buf.gen.yaml</code> file if you do not already have one with the following content or add <code>buf.build/meshapi/grpc-api-gateway</code> in your dependencies if you have an existing one:</p> buf.yaml<pre><code>version: v1\ndeps:\n  - \"buf.build/meshapi/grpc-api-gateway\"\n</code></pre> <p>Update mods to download the proto files:</p> <pre><code>$ buf mod update\n</code></pre> <p>You will first need to download the proto files for <code>gRPC API Gateway</code>. File named <code>grpc_api_gateway_proto.tar.gz</code> in the Releases page contains all the necessary proto files.</p> <p>From now on, use the <code>-I</code> or <code>--proto-path</code> option to include these proto files if they reside outside of the proto search path.</p> <p>In any proto file you wish to use annotations, use the import line below when wanting to use gateway or openapi options:</p> <pre><code>import \"meshapi/gateway/annotations.proto\";\n</code></pre>"},{"location":"reference/configuration/#using-configuration-files","title":"Using configuration files","text":"<p>Each proto file can have a single accompanying configuration file in YAML or JSON format that gets loaded along with the proto file. As the plug-in processes each proto file, it will use the config file pattern setting to determine a configuration file name and will try three file extensions <code>.yaml</code>, <code>.yml</code> and <code>.json</code> in that order. If a file exists, the configuration file gets loaded and the search ends.</p> <p>Note</p> <p>Both proto annotations and configurations files offer the same options in different formats. Thus there is no option that can be set using one method that cannot be set with the other.</p>"},{"location":"reference/configuration/#search-path","title":"Search Path","text":"<p>Since protoc compiler does not provide the full path to the proto files, it is NOT possible for the plug-ins to know the exact path of each proto file and cannot determine which directory to search for the configuration file. To address this issue, you can set search paths in the command line options for either plug-in to set the root directory where these configurations live.</p> <p>Search paths essentially set the root directory that will be used to search for configuration files. The default value will work for the majority of the use cases. However, if you want to place configuration files in a separate directory than your proto files or your file structures are more complex, you can use the search paths to direct the plug-ins where they should search.</p> <p>Default Value: default value is always <code>.</code> which means the current working directory of the <code>protoc</code> compiler.</p> Example <p>Imagine the following structure:</p> <pre><code>project/\n    proto/\n        models.proto\n</code></pre> <p>Assuming <code>protoc</code> is callled from the <code>project</code> directory:</p> <ul> <li>If search path is <code>.</code> (default value): directory <code>proto/</code> will be searched for the relative configuration file.</li> <li>If search path is <code>configs</code>, directory <code>configs/proto/</code> will be searched for the relative configuration file.</li> </ul>"},{"location":"reference/configuration/#filename-pattern","title":"Filename Pattern","text":"<p>We have discussed the search path and the directory that will be used to search for finding a relative configuration file for proto files. What is the file name? This setting can be used using command line flags in either plug-in to specify a convention based on the name of the proto file. To remain flexible, this value is a Go template value.</p> <p>Note</p> <p>This name must NOT contain the file extension since the tool itself will append and look for <code>.yaml</code>, <code>yml</code> and <code>.json</code> extensions in that order.</p> <p>Default Value: default value is always <code>{{ .Path }}_gateway</code> for both OpenAPI and API Gateway configuration files.</p> <p>This is a default but it can be changed according to your preferred file organization pattern.</p>"},{"location":"reference/configuration/#go-template-values","title":"Go Template Values","text":"<p>The following values are available to use in the configuration filename pattern.</p> <p>The value column shows the value for an example proto file <code>proto/myservice/v1/model.proto</code>.</p> Expression Description Value <code>{{.Name}}</code> is the base file name (no parent directorry) excluding <code>.proto</code> extension <code>model</code> <code>{{.Path}}</code> is the relative path to the file but excluding the <code>.proto</code> extension <code>proto/myservice/v1/model</code> <code>{{.Dir}}</code> is the relative path to the parent directory of the related proto file <code>proto/myservice/v1</code> <p>Example</p> <p>If search path is <code>/path/to/configs</code> and file pattern is <code>{{.Name}}_gateway</code>. Associated configuration file name (omitting file extension) for proto file <code>cool_service/v1/service.proto</code> is <code>/path/to/configs/cool_service/v1/service_gateway</code>.</p> <p>Warning</p> <p>Each <code>.proto</code> file can be associated with a single configuration file, meaning only one configuration will be loaded per .proto file. However, the same configuration file can be used by multiple <code>.proto</code> files if the configuration file pattern is customized (e.g. using <code>{{.Dir}}</code> expression).</p> <p>It is truly a matter of personal preference which method you would like to use to customize the gateway and/or the OpenAPI objects. It might be worth noting the following:</p> <ul> <li> <p>A JSON schema exists for YAML/JSON files so you benefit from autocompletion if you have installed the proper YAML/JSON extension.</p> </li> <li> <p>With many customization, proto files can get bloated. Separating the proto definitions from the gateway and OpenAPI configurations can help with the organization of files.</p> </li> </ul>"},{"location":"reference/intro/","title":"Introduction","text":"<p>This documentation provides comprehensive guidelines and code examples for utilizing OpenAPI v3.1 and gRPC API Gateway plug-ins.</p> <p>The project includes two essential <code>protoc</code> plug-ins:</p> <ol> <li> <p><code>protoc-gen-grpc-api-gateway</code>: This plug-in generates a reverse proxy in Go,    leveraging the code produced by the Go    and Go gRPC plug-ins.    The reverse proxy functions as an HTTP handler that converts HTTP requests into gRPC.</p> </li> <li> <p><code>protoc-gen-openapiv3</code>: This plug-in creates an OpenAPI v3.1 document for the reverse proxy HTTP server.    As OpenAPI v3.1 is tailored for RESTful HTTP APIs, this plug-in currently does not support WebSockets,    which may result in the exclusion of some streaming endpoints from the generated document.</p> </li> </ol>"},{"location":"reference/grpc/cli/","title":"Plug-in Options","text":"<p>The gRPC API Gateway protoc plug-in offers a variety of configurable options. The table below provides a comprehensive list of these options along with their descriptions and default values.</p> Option Description Default allow_delete_body Allows HTTP DELETE methods to include a body if explicitly specified. <code>false</code> allow_patch_feature Enables the use of the PATCH feature with update masks (<code>google.protobuf.FieldMask</code>). <code>true</code> config_search_path Specifies the directory (relative or absolute) from the current working directory that contains the gateway config files. See Search Path for more information. <code>.</code> gateway_config Path to the global gateway config file that is loaded first. This file can contain bindings for any service. No default gateway_config_pattern Pattern (excluding the extension) used to load a gateway config file for each proto file. The extensions <code>.yaml</code>, <code>.yml</code>, and <code>.json</code> will be tried in that order. See Filename Pattern for more details. <code>{{.Path}}_gateway</code> generate_local <code>Experimental</code> Generates code to directly use the server implementation instead of using gRPC clients. <code>false</code> generate_unbound_methods Includes unannotated RPC methods in the proxy. Methods without explicit HTTP bindings will default to POST with the route pattern <code>/&lt;grpc-service&gt;/&lt;method&gt;</code>. <code>false</code> log_file If specified, the plug-in writes all logs to this file. No default log_level Sets the log level. Available levels: <code>warning</code>, <code>info</code>, <code>trace</code>, and <code>silent</code>. <code>warning</code> omit_package_doc If true, no package comment will be included in the generated code. <code>false</code> register_func_suffix Suffix used to construct names of generated <code>Register*&lt;Suffix&gt;</code> methods. <code>Handler</code> repeated_path_param_separator Configures how repeated fields should be split. Allowed values are <code>csv</code>, <code>pipes</code>, <code>ssv</code>, and <code>tsv</code>. <code>csv</code> request_context Determines whether to use the HTTP request's context. <code>true</code> standalone Generates a standalone gateway package that imports the target service package. <code>false</code> warn_on_unbound_methods Emits a warning message if an RPC method has no mapping. <code>false</code>"},{"location":"reference/grpc/config/","title":"Configuration Reference","text":"<p>To define and bind HTTP endpoints to gRPC methods, you can use either configuration files or proto annotations directly within the proto files. For more details, refer to the Configuration documentation.</p> <p>Gateway configuration files should include the following object (<code>GatewayConfig</code>) under the <code>gateway</code> key:</p> Field Name Type Description <code>endpoints</code> [EndpointBinding] List of all gRPC-HTTP bindings. <p>Example</p> <pre><code>gateway:\n  endpoints:\n    - selector: \"~.MyService.MyMethod\"\n      get: \"/route\"\n</code></pre>"},{"location":"reference/grpc/config/#endpointbinding","title":"EndpointBinding","text":"<p>EndpointBinding represents an HTTP endpoint(s) to gRPC method binding.</p> Field Name Type Description <code>selector</code> string selector is a dot-separated gRPC service method selector.If the selector begins with <code>~.</code>, the current proto package will be added to the beginningof the path. For instance: <code>~.MyService</code>. Since no proto package can be deduced in the globalconfig file, this alias cannot be used in the global config file.If the selector does not begin with <code>~.</code>, it will be treated as a fully qualified method name (FQMN).NOTE: In proto annotations, this field gets automatically assigned, thus it is only applicable in configuration files. <code>get</code> string  (RoutePattern) get defines route for a GET HTTP endpoint. <code>put</code> string  (RoutePattern) put defines route for a PUT HTTP endpoint. <code>post</code> string  (RoutePattern) post defines route for a POST HTTP endpoint. <code>delete</code> string  (RoutePattern) delete defines route for a DELETE HTTP endpoint. <code>patch</code> string  (RoutePattern) patch defines route for a PATCH HTTP endpoint. <code>custom</code> CustomPattern custom can be used for custom HTTP methods.Not all HTTP methods are supported in OpenAPI specification and will not be included in thegenerated OpenAPI document. <code>body</code> string body is a request message field selector that will be read via HTTP body.<code>*</code> indicates that the entire request message gets decoded from the body.An empty string (default value) indicates that no part of the request gets decoded from the body.NOTE: Not all methods support HTTP body. <code>response_body</code> string response_body is a response message field selector that will be written to HTTP response.<code>*</code> or an empty string indicates that the entire response message gets encoded. <code>query_params</code> [ QueryParameterBinding ] query_params are explicit query parameter bindings that can be used to renameor ignore query parameters. <code>additional_bindings</code> [ AdditionalEndpointBinding ] additional_bindings holds additional bindings for the same gRPC service method. <code>disable_query_param_discovery</code> bool disable_query_param_discovery can be used to avoid auto binding query parameters.Default: <code>false</code> <code>stream</code> StreamConfig stream holds configurations for streaming methods."},{"location":"reference/grpc/config/#http-method-route","title":"HTTP Method &amp; Route","text":"<p>Each EndpointBinding object can define multiple HTTP bindings to a single gRPC method using the <code>additional_bindings</code> property. You must specify exactly one of the following fields to define the HTTP method: <code>get</code>, <code>post</code>, <code>put</code>, <code>patch</code>, <code>delete</code>, or <code>custom</code>.</p> <p>To use an HTTP method not listed, utilize the <code>custom</code> property.</p> <p>Warning</p> <p>Any HTTP method can be used for the gRPC gateway. However, OpenAPI specification supports only a limited set of HTTP methods. Unsupported methods will not appear in the generated OpenAPI documents.</p> <p>When using the <code>custom</code> field, the value must be a CustomPattern. For other fields, the value should be a RoutePattern.</p> <p>Example</p> ConfigurationProto Annotations sound_gateway.yaml<pre><code>gateway:\n  endpoints:\n    - post: \"/echo\"\n      selector: \"~.SoundService.Echo\"\n</code></pre> sound.proto<pre><code>service SoundService {\n    rpc Echo(EchoRequest) returns (EchoResponse) {\n        option (meshapi.gateway.http) = {\n            post: \"/echo\"\n        };\n    }\n}\n</code></pre>"},{"location":"reference/grpc/config/#routepattern","title":"RoutePattern","text":"<p>This is a string pattern that can contain parameters bound to the proto request fields. Message field selectors enclosed in curly braces get bound to the request message payload.</p> <p>For instance: <code>/path/{path.to.field}</code></p> <p>Example</p> <p>Consider the following request message: <pre><code>message NestedMessage {\n    string field = 1;\n}\n\nmessage Request {\n    NestedMessage nested = 1;\n    string name = 2;\n}\n</code></pre></p> <p><code>/path/{name}</code> would bind to field <code>name</code> of the <code>Request</code> message.</p> <p>Nested fields are supported so <code>/path/{name}/{nested.field}</code> is valid.</p>"},{"location":"reference/grpc/config/#wildcard","title":"Wildcard","text":"<p>If you want a field to contain all segments, including slashes, you can use the <code>{&lt;selector&gt;=*}</code> pattern.</p> <p>Example</p> <pre><code>message Request {\n    string file_path = 1;\n}\n</code></pre> <p>Route pattern <code>/path/{file_path=*}</code> would match <code>/path/a/b/c/d/e.jpg</code> and capture <code>file_path</code> as <code>/a/b/c/d/e.jpg</code>.</p>"},{"location":"reference/grpc/config/#additionalendpointbinding","title":"AdditionalEndpointBinding","text":"<p>This object is similar to EndpointBinding excluding the <code>additional_bindings</code> key.</p> <p>Example</p> ConfigurationProto Annotations sound_gateway.yaml<pre><code>gateway:\n  endpoints:\n    - get: \"/echo\"\n      selector: \"~.SoundService.Echo\"\n      additional_endpoints:\n        - get: \"/another-route\"\n        - post: \"/echo-with-post\"\n          body: \"*\"\n        - custom:\n            path: \"/echo\"\n            method: \"LOG\"\n</code></pre> sound.proto<pre><code>service SoundService {\n    rpc Echo(EchoRequest) returns (EchoResponse) {\n        option (meshapi.gateway.http) = {\n            get: \"/echo\",\n            additional_endpoints: [\n              {get: \"/another-route\"},\n              {post: \"/echo-with-post\", body: \"*\"},\n              {\n                custom: {method: \"LOG\", path: \"/echo\"}\n              }\n            ]\n        };\n    }\n}\n</code></pre>"},{"location":"reference/grpc/config/#custompattern","title":"CustomPattern","text":"<p>CustomPattern describes an HTTP pattern and custom method.</p> Field Name Type Description <code>method</code> string method is the custom HTTP method. <code>path</code> string path is the HTTP path pattern. <p>Example</p> ConfigurationProto Annotations sound_gateway.yaml<pre><code>gateway:\n  endpoints:\n    - custom:\n        method: \"TRACE\"\n        path: \"/echo\"\n      selector: \"~.SoundService.Echo\"\n</code></pre> sound.proto<pre><code>service SoundService {\n    rpc Echo(EchoRequest) returns (EchoResponse) {\n        option (meshapi.gateway.http) = {\n            custom: {\n                method: \"TRACE\",\n                path: \"/echo\"\n            }\n        };\n    }\n}\n</code></pre> <p>Warning</p> <p>Any HTTP method can be used and will function correctly in the gateway. However, methods not supported by OpenAPI will be excluded from the generated documentation.</p>"},{"location":"reference/grpc/config/#queryparameterbinding","title":"QueryParameterBinding","text":"<p>QueryParameterBinding describes a query parameter to request message binding.</p> Field Name Type Description <code>selector</code> string selector is a dot-separated path to the request message's field. <code>name</code> string name is the name of the HTTP query parameter that will be used. <code>ignore</code> bool ignore avoids reading this query parameter altogether (default: false). <p>By default, any field in the request proto message that is not bound to the HTTP body or path parameters will be automatically bound to query parameters.</p> <p>You can explicitly bind one or more fields to query parameters by specifying the proto message selector and the desired query parameter name. Alternatively, you can use <code>ignore</code> to exclude specific fields from being bound to query parameters.</p> <p>Example</p> <p>Consider the following request message: <pre><code>message EchoOptions {\n    int32 delay = 1;\n    bool lower_case = 2;\n}\n\nmessage EchoRequest {\n    EchoOptions options = 1;\n    string message = 2;\n}\n</code></pre></p> ConfigurationProto Annotations sound_gateway.yaml<pre><code>gateway:\n  endpoints:\n    - post: \"/echo\"\n      selector: \"~.SoundService.Echo\"\n      query_parameters:\n        - selector: \"message\"\n          name: \"msg\"\n        - selector: \"options.lower_case\" # (1)!\n          name: \"lower\"\n        - selector: \"options.delay\"\n          ignore: true # (2)!\n</code></pre> <ol> <li>Defining aliases for long or nested fields can simplify query parameters. For example, using <code>lower</code> instead of <code>options.lower_case</code>.</li> <li>Setting <code>ignore</code> to true prevents the <code>options.delay</code> proto field from being bound to any query parameter.</li> </ol> sound.proto<pre><code>service SoundService {\n    rpc Echo(EchoRequest) returns (EchoResponse) {\n        option (meshapi.gateway.http) = {\n            post: \"/echo\",\n            query_parameters: [\n                {selector: \"message\", name: \"msg\"},\n                {selector: \"options.lower_case\", name: \"lower\"}, // (1)!\n                {selector: \"options.delay\", ignore: true} // (2)!\n            ]\n        };\n    }\n}\n</code></pre> <ol> <li>Defining aliases for long or nested fields can simplify query parameters. For example, using <code>lower</code> instead of <code>options.lower_case</code>.</li> <li>Setting <code>ignore</code> to true prevents the <code>options.delay</code> proto field from being bound to any query parameter.</li> </ol> <p>In this example, in the HTTP request, you can use <code>msg</code> and <code>lower</code> query parameters directly:</p> <p><code>/echo?msg=something&amp;lower=true</code></p> <p>Info</p> <p>Defining aliases replaces the default auto-binding names. In the example above, using <code>msg</code> as an alias for the proto field <code>message</code> means only the query parameter <code>msg</code> will be bound to the proto field <code>message</code>. If you want to keep the original name as well, you can define multiple aliases for the same selector.</p>"},{"location":"reference/grpc/config/#streamconfig","title":"StreamConfig","text":"<p>StreamConfig sets the behavior of the HTTP server for gRPC streaming methods.</p> Field Name Type Description <code>disable_websockets</code> bool disable_websockets indicates whether or not websockets are allowed for this method.The client must still ask for a connection upgrade. <code>disable_sse</code> bool disable_sse indicates whether or not server-sent events are allowed.see: https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_eventsSSE is only used when Accept-Type from the request includes MIME type text/event-stream. <code>disable_chunked_transfer</code> bool disable_chunked indicates whether or not chunked transfer encoding is allowed.NOTE: Chunked transfer encoding is disabled in HTTP/2 so this option will only be available if the requestis HTTP/1. <p>Example</p> <p>Imagine an event streaming endpoint that continuously sends events to the client. Using chunked transfer for this is not ideal due to timeout constraints. However, using SSE (Server-Sent Events) or WebSockets is perfectly valid and recommended.</p> ConfigurationProto Annotations notification_gateway.yaml<pre><code>gateway:\n  endpoints:\n    - post: \"/notify\"\n      selector: \"~.NotificationService.Notify\"\n      stream:\n        disable_chunked_transfer: true\n</code></pre> notification.proto<pre><code>service NotificationService {\n    rpc Notify(NotifyRequest) returns (stream NotifyResponse) {\n        option (meshapi.gateway.http) = {\n            get: \"/events\",\n            stream: {\n                disable_chunked_transfer: true\n            }\n        };\n    }\n}\n</code></pre>"},{"location":"reference/grpc/errors/","title":"Handling Errors","text":"<p>Handling errors is always crucial, and this document provides an in-depth look into error handling:</p>"},{"location":"reference/grpc/errors/#gateway-errors","title":"Gateway Errors","text":"<p>There are several types of errors that can originate from the gateway itself. These include scenarios where a route is not found, marshaling or unmarshaling operations fail, a path parameter is missing or of an unexpected type, or an invalid enum value is received.</p> <p>All of these errors are distinct instances prefixed with <code>Err</code> within the <code>gateway</code> package. Each error instance encapsulates specific information that provides additional context and details.</p> <p>All of these errors can be mapped to gRPC error statuses with the appropriate error codes. Additionally, there are useful methods available to convert these gRPC codes to their corresponding HTTP status codes.</p> <p>The gateway comes with default error handlers that process all errors uniformly. If you wish to implement custom error handling logic, you can inspect the error to determine whether it originated from the gateway or from a service.</p> <p>Example</p> <pre><code>errorHandler := func(\n    ctx context.Context,\n    sm *gateway.ServeMux,\n    m gateway.Marshaler,\n    w http.ResponseWriter,\n    r *http.Request,\n    err error) {\n\n    pathParamError := gateway.ErrPathParameterInvalidEnum{}\n    if errors.As(err, &amp;pathParamError) {\n        // handle it differently.\n        log.Printf(\"invalid enum value for %s\", pathParamError.Name)\n        w.WriteHeader(http.StatusNotFound)\n    }\n\n    // use the default handler.\n    gateway.DefaultHTTPErrorHandler(ctx, sm, m, w, r, err)\n}\nhttpGateway := gateway.NewServeMux(gateway.WithErrorHandler(errorHandler))\n</code></pre> Function Description <code>WithErrorHandler</code> Manages all non-streaming HTTP errors, providing a centralized mechanism for error handling. <code>WithRoutingErrorHandler</code> Manages errors related to routes not being found, applicable to both streaming and unary modes. <code>WithStreamErrorHandler</code> Manages errors occurring during Chunked-Transfer encoding. <code>WithWebsocketErrorHandler</code> Manages errors specific to Websocket connections. <code>WithSSEErrorHandler</code> Manages errors related to Server-Sent Events (SSE)."},{"location":"reference/grpc/query/","title":"Query Parameter Binding","text":"<p>Understanding how query parameters are processed by the gRPC Gateway is crucial for customizing your API to meet specific needs.</p>"},{"location":"reference/grpc/query/#default-behavior","title":"Default Behavior","text":"<p>In each EndpointConfig, any proto field from the request message that is not already bound to path parameters or the HTTP body is automatically bound to query parameters.</p>"},{"location":"reference/grpc/query/#naming","title":"Naming","text":"<p>By default, the names of these query parameters are derived from the proto field names. For nested fields, the name is constructed by concatenating the parent field name with the nested field name, separated by a dot.</p> <p>Example</p> <p>Consider the following proto messages where <code>Request</code> is the request message:</p> <pre><code>message Options {\n    bool case_sensitive = 1;\n}\n\nmessage Request {\n    Options options = 1;\n    string some_input = 2;\n}\n</code></pre> <p>Assuming neither are captured by path parameters or the HTTP body, query parameters <code>some_input</code> and <code>options.case_sensitive</code> will be bound to the corresponding fields in the proto message.</p>"},{"location":"reference/grpc/query/#customization","title":"Customization","text":"<p>There are a number of customizations available.</p>"},{"location":"reference/grpc/query/#disable-automatic-discovery","title":"Disable Automatic Discovery","text":"<p>In EndpointConfig, you have the option to disable the automatic discovery and binding of query parameters. When this feature is disabled for a specific endpoint, only the query parameter bindings that are explicitly defined will be considered.</p> ConfigurationProto Annotations service_gateway.yaml<pre><code>gateway:\n  endpoints:\n    - post: \"/my-endpoint\"\n      selector: \"~.MyService.MyMethod\"\n      disable_query_param_discovery: true\n</code></pre> service.proto<pre><code>service MyService {\n    rpc MyMethod(Request) returns (Response) {\n        option (meshapi.gateway.http) = {\n            post: \"/my-endpoint\",\n            disable_query_param_discovery: true\n        };\n    }\n}\n</code></pre> <p>Some practical uses of this setting include:</p> <ul> <li>Assigning custom names to all query parameters.</li> <li>Restricting the exposure of certain parts of the proto message to the HTTP request.</li> </ul>"},{"location":"reference/grpc/query/#additional-query-parameter-binding-and-aliases","title":"Additional Query Parameter Binding and Aliases","text":"<p>To use custom names for query parameters or to allow multiple names (aliases) for the same message field, you can explicitly define the query parameter to request proto message field binding.</p> <p>By utilizing <code>query_params</code> in EndpointConfig, you can add multiple QueryParameterBinding objects.</p> <p>Example</p> <p>Consider request proto message below: <pre><code>message PageOptions {\n    uint32 per_page = 1;\n}\n\nmessage QueryRequest {\n    string term = 1;\n    string language = 2;\n    PageOptions pagination = 3;\n}\n</code></pre> Assume we want to achieve the following:</p> <ol> <li>Allow both <code>language</code> and <code>lang</code> as query parameters, with <code>language</code> taking precedence.</li> <li>Use <code>per_page</code> as the query parameter name instead of the default <code>pagination.per_page</code>.</li> </ol> ConfigurationProto Annotations query_gateway.yaml<pre><code>gateway:\n  endpoints:\n    - get: \"/query\"\n      selector: \"~.QueryService.Query\"\n      query_params:\n        - selector: 'language'\n          name: 'lang'\n        - selector: 'language'\n          name: 'language'\n        - selector: 'pagination.per_page'\n          name: 'per_page'\n</code></pre> query.proto<pre><code>service QueryService {\n    rpc Query(QueryRequest) returns (QueryResponse) {\n        option (meshapi.gateway.http) = {\n            get: \"/query\",\n            query_params: [\n                {selector: 'language', name: 'lang'},\n                {selector: 'language', name: 'language'},\n                {selector: 'pagination.per_page', name: 'per_page'}\n            ]\n        };\n    }\n}\n</code></pre> <p>With the configuration above:</p> <ul> <li>Both <code>language</code> and <code>lang</code> are accepted and bound to the <code>language</code> field in the proto request, with <code>language</code> taking precedence.</li> <li>The <code>per_page</code> query parameter is accepted and bound to <code>pagination.per_page</code>.</li> <li>The <code>term</code> field does not have an explicit binding but is automatically discovered and added.</li> </ul> <p>Warning</p> <p>Once you add an explicit binding for a proto field, that specific field will no longer receive automatic bindings. Only the explicitly defined bindings will be applied. For instance, in the example above, <code>pagination.per_page</code> is no longer automatically bound because an explicit binding for <code>pagination.per_page</code> is defined.</p>"},{"location":"reference/grpc/query/#prioritization","title":"Prioritization","text":"<p>If multiple names are defined for the same proto field, the most recently defined binding takes precedence over earlier ones. In the example above, <code>language</code> takes precedence over <code>lang</code>.</p>"},{"location":"reference/grpc/query/#ignoring-parameters","title":"Ignoring Parameters","text":"<p>You may want to exclude certain proto fields from being bound to any query parameters. To achieve this, you can use the <code>ignore</code> attribute in QueryParameterBinding. This will prevent the specified proto fields from being included in the query parameters.</p> <p>Example</p> ConfigurationProto Annotations query_gateway.yaml<pre><code>gateway:\n  endpoints:\n    - get: \"/query\"\n      selector: \"~.QueryService.Query\"\n      query_params:\n        - selector: 'language'\n          ignore: true\n</code></pre> query.proto<pre><code>service QueryService {\n    rpc Query(QueryRequest) returns (QueryResponse) {\n        option (meshapi.gateway.http) = {\n            get: \"/query\",\n            query_params: [\n                {selector: 'language', ignore: true},\n            ]\n        };\n    }\n}\n</code></pre> <p>Proto field <code>language</code> is excluded during the automatic discovery phase and, as a result, is not bound to any query parameter.</p>"},{"location":"reference/grpc/query/#data-types","title":"Data Types","text":"<p>This section explains how query parameter data is mapped to proto types. While mapping scalar types is straightforward, handling more complex data types like repeated values and maps can be less intuitive. Here, we clarify how various types are parsed from query parameters.</p> <p>Throughout this section, references to scalar types include all numerical types, booleans, strings, and enums.</p>"},{"location":"reference/grpc/query/#repeated-fields","title":"Repeated Fields","text":"<p>Repeated fields can hold multiple values. Query parameters support repeated fields only for scalar types.</p> <p>Example</p> <pre><code>message Request {\n    repeated string names = 1;\n}\n</code></pre> <p><code>?names=value1&amp;names=value2&amp;names=value3</code> gets mapped to <code>[\"value1\", \"value2\", \"value3\"]</code>.</p> <p>Info</p> <p>Commas in the value do not act as a separator and are instead read as part of the value.</p> <p>In the example above, <code>?names=value1,value2</code> gets mapped to <code>[\"value1,value2\"]</code>.</p>"},{"location":"reference/grpc/query/#maps","title":"Maps","text":"<p>Map types are also supported if both the key and the value are scalar types. The HTTP query parameter format is <code>field_name[key]=value</code>.</p> <p>Example</p> <pre><code>message Request {\n    map&lt;string, string&gt; metadata = 1;\n}\n</code></pre> <p><code>?metadata[key1]=value1&amp;metadata[key2]=value2</code> gets mapped to <code>{\"key1\": \"value1\", \"key2\": \"value2\"}</code>.</p>"},{"location":"reference/grpc/query/#unbound-query-parameters","title":"Unbound Query Parameters","text":"<p>All unbound query parameters are ignored without generating any errors.</p>"},{"location":"reference/grpc/streaming/","title":"Streaming","text":"<p>One of the main motivations for this project was to support streaming aspects of gRPC in the HTTP Gateway as well.</p> <p>Warning</p> <p>This feature and API are relatively new. While it is functional, it has not been extensively tested in high-latency production environments. Please conduct thorough testing and experimentation to ensure it meets the requirements of your project.</p>"},{"location":"reference/grpc/streaming/#streaming-modes","title":"Streaming Modes","text":"<p>This project supports three distinct streaming modes. It is highly recommended to review the documentation for each streaming mode you intend to use to fully understand their features and behaviors.</p> Streaming Mode Description HTTP Method Server-Sent Events (SSE) SSE allows the client to subscribe to a stream of events sent by the server over a single HTTP connection. GET WebSocket WebSocket enables bidirectional communication between the client and server over a single connection. GET Chunked-Transfer This method streams a message in multiple chunks, making it suitable for transferring large payloads efficiently. However, it is subject to short timeouts. *"},{"location":"reference/grpc/streaming/#1-server-sent-events-sse","title":"1. Server-sent events (SSE)","text":"<p>Server-sent events (SSE) is a technology that allows servers to push real-time updates to clients over a single, long-lived HTTP connection. Unlike WebSockets, which support bidirectional communication, SSE offers a simpler, one-way communication channel from the server to the client.</p> <p>SSE enables the server to continuously send updates to the client as new data becomes available. This makes it ideal for applications that require real-time notifications, such as live feeds, news updates, or stock price tickers. Clients subscribe to the stream by opening a persistent HTTP connection, allowing them to receive automatic updates without the need for repeated polling.</p> <p>Key features of SSE include:</p> <ul> <li>Ease of Implementation: SSE leverages standard HTTP protocols, ensuring straightforward integration and compatibility with existing web infrastructure.</li> <li>Automatic Reconnection: Provides built-in support for automatic reconnection if the connection is lost, enhancing reliability.</li> <li>Event Identification: Supports event IDs, enabling clients to track the last received event and resume from where they left off seamlessly.</li> </ul> <p>To utilize SSE, the client opens a connection to an endpoint that delivers events, and the server streams text-based event data, typically in the form of plain text or JSON.</p> <p>You can use SSE for any gRPC method as long as:</p> <ol> <li>The server returns a stream, which includes both server-streaming and bidirectional modes.</li> <li>The HTTP method is GET.</li> </ol> <p>Note</p> <p>While bidirectional gRPC methods are supported, it's crucial to understand that SSE is strictly server-streaming. Although requests can be streamed to the server using Chunked-Transfer, the client cannot send messages arbitrarily with SSE. Instead, the client streams its request and then waits for the server to push messages.</p>"},{"location":"reference/grpc/streaming/#note-on-closing-the-stream","title":"Note on closing the stream","text":"<p>When using SSEs in the browser, if the connection is closed for any reason other than the client closing the stream, the browser will attempt to re-establish the connection.</p> <p>To handle this, if the gRPC server implementation closes the stream, it sends an End-of-stream (EOS) message to indicate that the stream has ended and no more events will be sent. Upon receiving this message, you should close the stream. This message can be customized if you prefer to send different content.</p> <p>The default EOS message has an ID of <code>EOS</code>, an Event of <code>EOS</code>, and no data.</p> <pre><code>id: EOS\nevent: EOS\ndata:\n</code></pre> <p>To use a custom EOS message:</p> <pre><code>gateway.NewServeMux(gateway.WithSSEConfig(gateway.SSEConfig{EndOfStreamMessage: nil}))\n</code></pre> <p>Example</p> <pre><code>const notificationsSource = new EventSource(\"/notifications\");\n\nnotificationsSource.onmessage = (event) =&gt; {\n  console.log(`New Event: ${event.data}`)\n};\n\nnotificationsSource.addEventListener('EOS', (event) =&gt; {\n  console.log(`End of stream received, server does not want to send more events. Closing the event source.`);\n  notificationsSource.close();\n});\n</code></pre> <p>Info</p> <p>If your gRPC method implementation is designed to end the stream, it may be worth reconsidering whether SSE is the most suitable choice for your needs.</p>"},{"location":"reference/grpc/streaming/#custom-events","title":"Custom Events","text":"<p>One of the key features of SSE is the ability to push messages with specific event names. Currently, all SSE messages (except for the EOS message) do not include <code>event</code> or <code>id</code> values. In the future, it will be possible to use gRPC metadata to specify these properties, but this functionality is not available at present.</p> <p>As a result, all messages will be received using the <code>onmessage</code> handler when using JavaScript in the browser:</p> <pre><code>const eventSource = new EventSource(\"/path/to/endpoint\");\n\neventSource.onmessage = (event) =&gt; {\n  // event.message\n};\n</code></pre>"},{"location":"reference/grpc/streaming/#important-note-for-http-11","title":"Important Note for HTTP 1.1","text":"<p>Warning</p> <p>When not used over HTTP/2, SSE is limited by the maximum number of open connections, which can be particularly problematic when opening multiple tabs. This limit is set to a very low number (6) per browser.</p> <p>This issue has been marked as \"Won't fix\" in both Chrome and Firefox. The limit is per browser and domain, meaning you can open 6 SSE connections across all tabs to www.example1.com and another 6 SSE connections to www.example2.com.</p> <p>When using HTTP/2, the maximum number of simultaneous HTTP streams is negotiated between the server and the client, with a default of 100.</p>"},{"location":"reference/grpc/streaming/#error-handling","title":"Error Handling","text":"<p>If an error is returned by the server, it is handled using the <code>SSEErrorHandlerFunc</code>, and the connection will be closed. To communicate errors without closing the connection, include the error structure in your proto response messages.</p> <p>By default, the error received from the server is marshaled and sent to the client. To customize this behavior and use your own error handler for SSE connections, use the <code>WithSSEErrorHandler</code> option:</p> <pre><code>gateway.NewServeMux(gateway.WithSSEErrorHandler(myCustomErrorHandler))\n</code></pre>"},{"location":"reference/grpc/streaming/#using-outside-of-browsers","title":"Using outside of browsers","text":"<p>Server-sent events can be used outside of browsers as well. Reading specification of SSE is the best way to learn how to correctly use this feature. However, to use the SSE streaming mode, send <code>Accept: text/event-stream</code> header in your HTTP request.</p>"},{"location":"reference/grpc/streaming/#2-websockets","title":"2. WebSockets","text":"<p>WebSockets is a communication protocol that provides full-duplex communication channels over a single TCP connection. It enables real-time data transfer between clients and servers with low latency, making it ideal for interactive web applications such as live chat, streaming, and multiplayer games. WebSockets are initiated through an HTTP handshake and then upgraded to a persistent connection, facilitating efficient data exchange.</p> <p>While WebSockets offer significant advantages for streaming, there are several limitations and challenges to consider:</p> <ul> <li> <p>Scalability: Managing a large number of concurrent WebSocket connections can be resource-intensive and complex, requiring robust server infrastructure and effective load balancing strategies.</p> </li> <li> <p>Network Issues: WebSocket connections can be prone to interruptions due to network instability, necessitating efficient reconnection strategies to maintain a seamless user experience.</p> </li> <li> <p>Security: Secure WebSocket communication requires implementing encryption (TLS/SSL), authentication, and protection against common attacks such as cross-site WebSocket hijacking.</p> </li> <li> <p>Browser Compatibility: Although most modern browsers support WebSockets, some older versions do not. This necessitates fallback mechanisms like long polling or Server-Sent Events (SSE).</p> </li> <li> <p>Firewall and Proxy Restrictions: WebSocket traffic can be blocked or interfered with by some firewalls and proxies, requiring additional configurations to ensure proper connections.</p> </li> <li> <p>Error Handling: Effective error management and handling of edge cases in WebSocket communication are essential for maintaining application stability and ensuring a good user experience.</p> </li> <li> <p>State Management: Tracking client state across WebSocket connections can be complex, especially in distributed systems or applications that require high availability and fault tolerance.</p> </li> </ul>"},{"location":"reference/grpc/streaming/#enabling-websockets","title":"Enabling WebSockets","text":"<p>To enable the gRPC API Gateway to support a WebSocket interface for your gRPC streaming API, you need to provide a custom connection upgrader. This allows you to manage the specifics of WebSocket connections, such as authorization, compression, and other concerns.</p> <p>By default, the gateway does not include a WebSocket handler. You must supply a custom connection upgrader to handle message sending and receiving. This approach gives you control over WebSocket-specific details and ensures the gRPC API Gateway can integrate seamlessly with various WebSocket libraries, allowing you to choose the one that best fits your needs.</p> <p>Info</p> <p>gorilla/websocket is a popular Go implementation of the WebSocket protocol. There is a rudimentary wrapper for integrating this library with the gRPC API Gateway. This wrapper is used in all the examples in this section.</p> <p>To use this wrapper:</p> <pre><code>go get github.com/meshapi/grpc-api-gateway/websocket/wrapper/gorillawrapper\n</code></pre> <p>To enable WebSockets in your gateway, use <code>WithWebSocketUpgrader</code> option:</p> <pre><code>gateway.NewServeMux(gateway.WithWebsocketUpgrader(websocketUpgradeFunc))\n</code></pre> <p>The upgrader function has the following signature:</p> <p><code>func(w http.ResponseWriter, r *http.Request) (websocket.Connection, error)</code></p> <p>Example</p> <p>Below is an example using the gorilla/websocket library:</p> <pre><code>import (\n  ws \"github.com/meshapi/grpc-api-gateway/websocket\"\n  \"github.com/meshapi/grpc-api-gateway/websocket/wrapper/gorillawrapper\"\n  \"github.com/meshapi/grpc-api-gateway/gateway\"\n\n  \"github.com/gorilla/websocket\"\n)\n\n// ...\n\nupgrader := websocket.Upgrader{\n    CheckOrigin: func(r *http.Request) bool {\n        return true // NB: not ideal for production code.\n    },\n}\n\nwebsocketUpgradeFunc := gateway.WebsocketUpgradeFunc(\n    func(w http.ResponseWriter, r *http.Request) (ws.Connection, error) {\n        connection, err := upgrader.Upgrade(w, r, nil) //(1)!\n        if err != nil {\n            log.Printf(\"ws error: %s\", err)\n            return nil, fmt.Errorf(\"failed to upgrade: %w\", err)\n        }\n\n        return gorillawrapper.New(connection), nil //(2)!\n    })\n\ngrpcGateway := gateway.NewServeMux(gateway.WithWebsocketUpgrader(websocketUpgradeFunc))\n</code></pre> <ol> <li>WebSocket connection is prepared here using the WebSocket library of choice.</li> <li>A thin adaptor is used to wrap the WebSocket connection only to return a <code>ws.Connection</code> type.</li> </ol> <p>Info</p> <p>If no WebSocket upgrader is specified using <code>WithWebSocketUpgrader</code>, all requests asking for a WebSocket protocol upgrade receive an error indicating the streaming method is not supported.</p>"},{"location":"reference/grpc/streaming/#error-handling_1","title":"Error Handling","text":"<p>If an error occurs while receiving or sending messages, a WebSocket-specific error handler will be triggered to manage the encountered error. After the error is handled, both the WebSocket connection and the gRPC streams will be terminated. As a result, a reconnection will be necessary to continue sending or receiving messages.</p> <p>To report an error without closing or interrupting the connection, include an error structure in your proto response messages.</p>"},{"location":"reference/grpc/streaming/#3-chunked-transfer","title":"3. Chunked Transfer","text":"<p>Chunked Transfer is a streaming method that, unlike other streaming modes, is not long-lived. This mode is ideal for streaming large messages in chunks. For example, if a user needs to load a large number of items, fetching these items might be quick, but transmitting them over the network can be time-consuming. Chunked-Transfer encoding allows you to process items as they are received, making the transfer more efficient.</p>"},{"location":"reference/grpc/streaming/#error-handling_2","title":"Error Handling","text":"<p>Similar to the other methods, if any error is encountered, the stream get interrupted immediately and the error handler gets called. To use a custom error handler logic, use <code>WithStreamErrorHandler</code> option:</p> <pre><code>gateway.NewServeMux(gateway.WithStramErrorHandler(myCustomHandler))\n</code></pre>"},{"location":"reference/grpc/streaming/#toggles-disable-streaming","title":"Toggles / Disable streaming","text":"<p>All streaming modes are enabled by default. However, enabled does not imply they are immediately available; it means they are permitted to be used when the appropriate conditions are met.</p> <p>WebSockets can only be utilized on endpoints with the <code>GET</code> method, and you must have added an Upgrader to enable the WebSockets streaming mode. Server-sent events (SSE) also require <code>GET</code> endpoints and the <code>Accept</code> header with <code>text/event-stream</code> in the request.</p> <p>To disable a specific streaming mode for an endpoint binding, use the Stream configuration.</p> <p>Example</p> <p>Imagine an endpoint for a chat application. This method supports bidirectional streaming and can technically accept Chunked-Transfer encoding or Server-sent events. However, using these modes is impractical because Chunked-Transfer does not support long-lived connections, and SSE does not allow the client to send messages to the server.</p> ConfigurationProto Annotations chat_gateway.yaml<pre><code>gateway:\n  endpoints:\n    - get: \"/chat\"\n      selector: \"~.ChatService.StartChat\"\n      stream:\n        disable_sse: true\n        disable_chunked_transfer: true\n</code></pre> service.proto<pre><code>service ChatService {\n    rpc StartChat(ChatRequest) returns (ChatResponse) {\n        option (meshapi.gateway.http) = {\n            get: \"/chat\",\n            stream: {\n              disable_sse: true,\n              disable_chunked_transfer: true\n            }\n        };\n    }\n}\n</code></pre> <p>Now, these endpoint bindings do NOT accept SSE or Chunked-Transfer and return streaming not supported error.</p>"},{"location":"reference/openapi/cli/","title":"Plug-in Options","text":"<p>The OpenAPI v3 protoc plug-in offers a variety of configurable options. The table below provides a comprehensive list of these options along with their descriptions and default values.</p> <p>Note that there are some overlaps between gRPC options and OpenAPI options. To ensure the OpenAPI plug-in generates an accurate OpenAPI document that matches your gRPC API Gateway, it is important to use the same options in both the gRPC API Gateway and OpenAPI v3 plug-ins.</p> <p>Example</p> <p>If you use <code>allow_delete_body</code> in the gRPC API Gateway, ensure the same value is set for the OpenAPI v3 plug-in. This alignment guarantees that the generated OpenAPI document accurately reflects the gRPC API's behavior.</p> Option Description Default allow_delete_body Allows HTTP DELETE methods to include a body if explicitly specified. <code>false</code> allow_patch_feature Enables the use of the PATCH feature with update masks (<code>google.protobuf.FieldMask</code>). <code>true</code> disable_default_errors When enabled, the default error response is not generated. This is useful if you are using a custom error structure. <code>false</code> disable_default_responses When enabled, the default success response is not generated. This is particularly useful when you need to specify non-200 status codes. <code>false</code> disable_service_tags When enabled, prevents the generation of service tags in operations. This helps to avoid exposing backend gRPC service names. <code>false</code> field_name_mode Controls the naming convention of fields in the OpenAPI schemas. Allowed values are <code>proto</code> for using the original proto field names and <code>json</code> for using camelCase JSON names. <code>json</code> field_nullable_mode Configures the generation of nullable OpenAPI fields for scalar types using <code>anyOf</code> or type array. Options include: <code>disabled</code> (no nullable fields generated), <code>optional</code> (nullable fields generated when the proto3 optional label is used), and <code>not_required</code> (nullable fields generated when a field is not explicitly marked as required and can be null). <code>optional</code> field_required_mode Configures the automatic marking of fields as required. Options include: <code>disabled</code> (default) does not automatically mark any field as required, <code>non_optional</code> marks any field that is not labeled as optional as required, and <code>non_optional_scalar</code> marks only scalar types (not message types) that are not labeled as optional as required. <code>disabled</code> config_search_path Specifies the directory (relative or absolute) from the current working directory that contains the gateway config files. See Search Path for more information. <code>.</code> gateway_config Path to the global gateway config file that is loaded first. This file can contain bindings for any service. No default gateway_config_pattern Pattern (excluding the extension) used to load a gateway config file for each proto file. The extensions <code>.yaml</code>, <code>.yml</code>, and <code>.json</code> will be tried in that order. See Filename Pattern for more details. <code>{{.Path}}_gateway</code> openapi_config If set, this configuration file is used as a top-level config for all proto files and services. You can use a single config file for both gRPC and OpenAPI configurations. By default, if a gateway config is specified, and unless '-' is used for openapi_config, the same config file will be used for OpenAPI configurations as well. No default openapi_config_pattern Specifies the pattern (excluding the extension) used to load an OpenAPI config file for each proto file containing service definitions. The extensions <code>.yaml</code>, <code>.yml</code>, and <code>.json</code> will be tried in that order. <code>{{ .Path }}_gateway</code> openapi_seed_file If set, this OpenAPI file (YAML or JSON) is used as a template and merged with the generated files. This is useful for setting values not available in the OpenAPI generation configs or for repeating document values across all generated files. No default generate_unbound_methods Includes unannotated RPC methods in the proxy. Methods without explicit HTTP bindings will default to POST with the route pattern <code>/&lt;grpc-service&gt;/&lt;method&gt;</code>. <code>false</code> use_go_templates When enabled, allows the use of Go templates for tags, titles, summaries, and links. Refer to the documentation for available template values. <code>false</code> go_template_args Allows the assignment of Go template arguments in a comma-separated format. Example: <code>a=b,c=d</code>. No default ignore_comments When enabled, all proto documentation and comments are completely ignored. <code>false</code> remove_internal_comments When enabled, excludes any string wrapped in <code>(--</code> and <code>--)</code> from the generated output. <code>false</code> include_package_in_tags Specifies whether to include the proto package name in the service name used in the operation tags. <code>false</code> operation_id_mode Controls the format of operation IDs in the OpenAPI document. Options are: <code>service+method</code> for <code>&lt;Service&gt;_&lt;Method&gt;</code>, <code>method</code> for just the method name, and <code>fqn</code> for the fully qualified name. The default is <code>service+method</code>. <code>service+method</code> include_services_only When enabled, generates only the bound service methods and the models required to support them. <code>false</code> local_package_mode When enabled, restricts each configuration file (except the global config) to the local proto package. <code>false</code> log_file If specified, the plug-in writes all logs to this file. No default log_level Sets the log level. Available levels: <code>warning</code>, <code>info</code>, <code>trace</code>, and <code>silent</code>. <code>warning</code> merge_with_overwrite When enabled, this option causes arrays to be overwritten rather than appended. <code>true</code> omit_empty_files When enabled, skips the generation of OpenAPI documents that do not contain at least one schema or path. <code>false</code> omit_enum_default_value When enabled, omits the default value for all enum fields in the generated OpenAPI document. <code>false</code> use_enum_numbers When enabled, enums in the OpenAPI document will use their numerical values instead of string representations. <code>false</code> repeated_path_param_separator Configures how repeated fields should be split. Allowed values are <code>csv</code>, <code>pipes</code>, <code>ssv</code>, and <code>tsv</code>. <code>csv</code> warn_on_unbound_methods Emits a warning message if an RPC method has no mapping. <code>false</code> warn_on_broken_selectors When enabled, reduces the severity of unrecognized selectors in configuration files to a warning level in the logs. <code>false</code> schema_naming_strategy Controls the naming convention for OpenAPI schemas. Options include: <code>fqn</code> for using the fully qualified name, <code>simple</code> for using the shortest unique name, and <code>simple+version</code> for including a version prefix when available (e.g., <code>v1alpha1Message</code>). <code>simple</code> visibility_selectors A comma-separated list of visibility labels to include. Example: <code>INTERNAL,PARTNERS</code>. When empty, all methods are selected. No default output_mode Determines how the OpenAPI definitions are organized in the output. Options are: <code>merge</code> to combine all definitions into a single file, <code>proto</code> to generate one file per proto file, and <code>service</code> to create a separate document for each gRPC service. <code>proto</code> output_filename Applicable only when using the <code>merge</code> output mode. This option sets the filename for the generated OpenAPI document. <code>apidocs</code> output_format Specifies the format of the generated output. Allowed values are <code>yaml</code> and <code>json</code>. <code>json</code>"},{"location":"reference/openapi/config/","title":"Configuration Reference","text":"<p>The OpenAPI 3.1 specification includes numerous fields and configurations, many of which are supported and recognized by the OpenAPI plug-in.</p> <p>For comprehensive guidelines on OpenAPI 3.1, please refer to this link.</p> <p>You can access the full list of annotations applicable to both proto files and configuration files here.</p>"},{"location":"reference/openapi/config/#json-schema","title":"JSON Schema","text":"<p>We recommend using an IDE tool that supports JSON/YAML Schemas based on the file format. This can help you with auto-completion when using the configuration files.</p> <p>You can also access the schema file here.</p>"},{"location":"reference/openapi/config/#field-configuration","title":"Field Configuration","text":"<p>While most of the OpenAPI annotations are directly related to the OpenAPI 3.1 specification, Field Configuration allows you to modify the behavior of the OpenAPI plug-in itself, rather than the specification.</p>"},{"location":"reference/openapi/config/#path_param_name","title":"path_param_name","text":"<p>Allows you to specify an alternative name for this field when it is utilized as a path parameter.</p>"},{"location":"reference/openapi/config/#required","title":"required","text":"<p>Allows you to mark the field as required on the field directly. See Explicitly Define Required Fields for other ways to mark the field as required.</p>"},{"location":"reference/openapi/config/#openapi-differences","title":"OpenAPI differences","text":"<p>While the majority of the annotations align closely with the OpenAPI specification, there are a few notable differences and unique elements that should be highlighted.</p>"},{"location":"reference/openapi/config/#type-slice","title":"Type Slice","text":"<p>Type in the OpenAPI 3.1 specification can be either a single string or an array of strings. In the annotations, it is always represented as an array. However, if only one item is present, the final OpenAPI output will simplify it to a single value.</p>"},{"location":"reference/openapi/config/#references","title":"References","text":"<p>In Schemas, you can use <code>ref</code> to refer to a proto message and popuate its details.</p> Proto fileConfiguration <pre><code>import \"meshapi/gateway/annotations.proto\";\n\nservice MyService {\n    rpc Do(Request) returns (Response) {\n        option (meshapi.gateway.openapi_operation) = {\n            responses: [\n                {\n                    key: \"206\",\n                    value: {\n                        content: [\n                            {\n                                key: \"application/json\",\n                                value: {\n                                    schema: {\n                                        ref: \".main.PartialResponse\"\n                                    }\n                                }\n                            }\n                        ]\n                    }\n                }\n            ]\n        };\n    };\n}\n</code></pre> <pre><code>openapi:\n  services:\n    - selector: \"~.MyService\"\n      methods:\n        Do:\n          responses:\n            \"206\":\n              content:\n                application/json:\n                  schema:\n                    ref: \".main.PartialResponse\"\n</code></pre>"},{"location":"reference/openapi/config/#extras","title":"Extras","text":"<p>If you need to specify any additional fields from the OpenAPI specification that are not covered by the annotations, or if you have custom fields you want to include (such as custom extensions), you can use the <code>extra</code> property to add these keys:</p> Proto fileConfiguration <pre><code>import \"meshapi/gateway/annotations.proto\";\n\nmessage User {\n    option (meshapi.gateway.openapi_schema) = {\n    extra: [\n      {key: \"x-custom-key\", value: {string_value: \"value\"}}\n    ]\n  };\n}\n</code></pre> <pre><code>openapi:\n  messages:\n    - selector: \"~.User\"\n      schema:\n        extra:\n          key: value\n</code></pre>"},{"location":"reference/openapi/field_optionality/","title":"Field Optionality &amp; Nullability","text":"<p>In OpenAPI documents and JSON schemas, a field can specify its nullability and requiredness. It is crucial to accurately map the proto labels to the JSON schema to ensure a correct representation of your API. Each API can have its own unique set of patterns. In this document, you will learn how to configure the OpenAPI plug-in to adjust the way these specifications are mapped to proto labels.</p>"},{"location":"reference/openapi/field_optionality/#field-nullability","title":"Field Nullability","text":"<p>In OpenAPI and JSON schemas, a field can specify whether it accepts null values. In OpenAPI v3.1, the correct way to represent this is by using type arrays.</p> <p>Example</p> <pre><code>{\n  \"nullable_field\": {\n    \"type\": [\"string\", \"null\"]\n  },\n  \"string_field\": {\n    \"type\": \"string\"\n  }\n}\n</code></pre> <p>How does this map to proto fields? Let's consider the proto message below:</p> <pre><code>message User {\n  string id = 1;\n  string name = 2;\n  optional string email_address = 3;\n  optional Address address = 4;\n  PhoneNumber phone_number = 5;\n}\n</code></pre> <p>Protobuf can handle null values, where a null value indicates an unspecified value. If you assigned null values to every key in a JSON object for the proto message above, the model would be mapped as follows:</p> <pre><code>{\n  \"id\": \"\", // (1)!\n  \"name\": \"\",\n  \"email_address\": null, // (2)!\n  \"address\": null, // (3)!\n  \"phone_number\": null // (4)!\n}\n</code></pre> <ol> <li><code>id</code> is a string, a primitive type, and is not marked as optional. Therefore, it will be assigned its default value, which is an empty string.</li> <li><code>email_address</code> is a string, a primitive type, and is explicitly marked as optional. This means it can differentiate between having no value and being blank. Therefore, it is assigned <code>null</code>.</li> <li><code>address</code> is an optional message type. Similar to <code>email_address</code>, because it is labeled as <code>optional</code>, it is nullable and thus receives <code>null</code>.</li> <li>Unlike <code>address</code>, <code>phone_number</code> is not marked as an optional field. However, since it is a message type, it is inherently nullable and thus also receives <code>null</code>.</li> </ol> <p>That is how protobuf handles unmarshaling bytes into in-memory structures. How should this be represented in OpenAPI? If <code>phone_number</code> is intended to be set and a null value is unacceptable, this requirement must be clearly documented in the OpenAPI specification.</p> <p>This can be controlled via <code>field_nullable_mode</code> plug-in option.</p>"},{"location":"reference/openapi/field_optionality/#1-disabled","title":"1. Disabled","text":"<p>Value of <code>disabled</code> for <code>field_nullable_mode</code> would enable this mode.</p> <p>Disabled means that nullability will not be automatically documented. For the proto message above, this results in a JSON schema where none of the fields are marked as nullable.</p> <p>You can manually adjust the nullability settings as needed:</p> <p>Below is an example of explicitly setting the OpenAPI types via configuration files.</p> <pre><code>openapi:\n  messages:\n    - selector: \"User\"\n      fields:\n        email_address:\n          types:\n            - STRING\n            - \"NULL\"\n</code></pre> <p>This can also be achieved directly within proto files as well:</p> <pre><code>message User {\n  string id = 1;\n  string name = 2;\n  optional string email_address = 3 [\n    (meshapi.gateway.openapi_field) = {\n        types: [STRING, NULL]\n    }\n  ];\n  optional Address address = 4;\n  PhoneNumber phone_number = 5;\n}\n</code></pre>"},{"location":"reference/openapi/field_optionality/#2-nullable-if-optional-default","title":"2. Nullable If Optional (Default)","text":"<p>Value of <code>optional</code> for <code>field_nullable_mode</code> would enable this mode.</p> <p>This mode treats any proto field marked as <code>optional</code> as nullable.</p> <p>In the proto message above, the <code>email_address</code> and <code>address</code> fields would be represented in the OpenAPI document as accepting <code>null</code> values, while the other fields would not include <code>null</code> as an accepted value.</p>"},{"location":"reference/openapi/field_optionality/#3-nullable-unless-required","title":"3. Nullable Unless Required","text":"<p>Value of <code>non_required</code> for <code>field_nullable_mode</code> would enable this mode.</p> <p>This mode treats all fields as nullable unless they are explicitly marked as required.</p> <p>Follow the guidelines in Explicitly Define Required Fields to specify which fields should be marked as required.</p>"},{"location":"reference/openapi/field_optionality/#field-requiredness","title":"Field Requiredness","text":"<p>In JSON Schema and OpenAPI, requiredness and nullability are distinct concepts:</p> <ul> <li>Requiredness: Determines whether a field must be present in the JSON object. If a field is required, it must be included in the object, but it can still have a null value unless specified otherwise.</li> <li>Nullability: Specifies whether a field can have a null value. A nullable field can explicitly be set to null, indicating the absence of a value.</li> </ul> <p>In OpenAPI v3.1, nullability is indicated using type arrays (e.g., <code>[\"string\", \"null\"]</code>), while requiredness is specified using the <code>required</code> keyword at the object level.</p> <p>We discussed field nullability in the previous section. Now, let's use the same object to explore the concept of requiredness.</p> <p>Consider the proto message below:</p> <pre><code>message User {\n  string id = 1;\n  string name = 2;\n  optional string email_address = 3;\n  optional Address address = 4;\n  PhoneNumber phone_number = 5;\n}\n</code></pre> <p>You can configure the OpenAPI plug-in to automatically mark certain fields as required using <code>field_required_mode</code>. By default, this feature is disabled, meaning no fields are automatically marked as required.</p>"},{"location":"reference/openapi/field_optionality/#1-disabled-default","title":"1. Disabled (Default)","text":"<p>Value of <code>disabled</code> for <code>field_required_mode</code> would enable this mode.</p> <p>As previously mentioned, this means the OpenAPI plug-in will not automatically determine the requiredness of any field. However, you can manually specify which fields are required.</p>"},{"location":"reference/openapi/field_optionality/#explicitly-define-required-fields","title":"Explicitly Define Required Fields","text":"<p>There are several ways to mark a field as required:</p> <p>1. At the message level:</p> <p>This approach mirrors how OpenAPI specifies required fields. Each model explicitly lists all properties that are required:</p> Proto AnnotationsConfiguration <pre><code>import \"meshapi/gateway/annotations.proto\";\n\nmessage User {\n  (meshapi.gateway.openapi_schema) = {\n    required: [\"id\", \"name\", \"phone_number\"] // (1)!\n  }\n\n  string id = 1;\n  string name = 2;\n  string email_address = 3;\n  Address address = 4;\n  PhoneNumber phone_number = 5;\n}\n</code></pre> <ol> <li>Indicates that fields <code>id</code>, <code>name</code> and <code>phone_number</code> do not accept null values.</li> </ol> <pre><code>openapi:\n  messages:\n    - selector: \"User\"\n      schema:\n        required:\n          - \"id\"\n          - \"name\"\n          - \"phone_number\"\n</code></pre> <p>2. At the field level:</p> <p>This approach sets the requiredness at the field.</p> Proto AnnotationsConfiguration <pre><code>import \"meshapi/gateway/annotations.proto\";\n\nmessage User {\n  string id = 1 [(meshapi.gateway.openapi_field).config.required=true];\n  string name = 2 [(meshapi.gateway.openapi_field).config.required=true];\n  string email_address = 3;\n  Address address = 4;\n  PhoneNumber phone_number = 5 [\n    (meshapi.gateway.openapi_field).config.required = true\n  ];\n}\n</code></pre> <pre><code>openapi:\n  messages:\n    - selector: \"User\"\n      fields:\n        id:\n          config:\n            required: true\n        name:\n          config:\n            required: true\n        phone_number:\n          config:\n            required: true\n</code></pre>"},{"location":"reference/openapi/field_optionality/#2-required-if-not-optional","title":"2. Required If Not Optional","text":"<p>Value of <code>non_optional</code> for <code>field_required_mode</code> would enable this mode.</p> <p>This mode designates all proto fields as required by default, except for those explicitly marked as optional.</p> <p>Thus, in the proto message defined above, the fields <code>id</code>, <code>name</code>, and <code>phone_number</code> would be considered required.</p>"},{"location":"reference/openapi/field_optionality/#3-required-if-not-optional-scalar","title":"3. Required If Not Optional &amp; Scalar","text":"<p>Value of <code>non_optional_scalar</code> for <code>field_required_mode</code> would enable this mode.</p> <p>This mode designates proto fields as required if all of the following conditions are met:</p> <ol> <li>The field is a primitive type or a list of primitive types (e.x. <code>repeated string</code>).</li> <li>The field is not a map.</li> <li>The field is not a message.</li> <li>The field is not marked as optional.</li> </ol> <p>Thus, in the proto message defined above, the fields <code>id</code> and <code>name</code> would be considered required. Since <code>phone_number</code> is a message type, it is not considered required in this mode.</p>"},{"location":"reference/openapi/field_optionality/#mix-match","title":"Mix &amp; Match","text":"<p>You have the flexibility to configure requiredness and nullability automatically using the OpenAPI plug-in, allowing you to combine different rules for these attributes. For example, by setting <code>field_required_mode</code> to <code>non_optional</code> and <code>field_nullable_mode</code> to <code>non_required</code>, any field that is not explicitly required will be considered nullable. In this configuration, requiredness is automatically determined based on whether your proto fields are marked as optional.</p> <p>In this mode, proto message <code>User</code> as defined below:</p> <pre><code>message User {\n  string id = 1;\n  string name = 2;\n  optional string email_address = 3;\n  optional Address address = 4;\n  PhoneNumber phone_number = 5;\n}\n</code></pre> <p>would treat the fields <code>id</code>, <code>name</code>, and <code>phone_number</code> as required and non-nullable by default (unless explicitly configured otherwise). Conversely, the fields <code>email_address</code> and <code>address</code> would be considered optional and nullable. This can be achieved without any custom annotations or configuration files. If your API follows a consistent pattern like this, adjusting these two modes can help avoid the need to configure these fields individually.</p>"},{"location":"reference/openapi/go_template/","title":"Go Template","text":"<p>You can use Go Templates to generate documentation or parts of the OpenAPI specification based on the types defined in your proto files.</p> <p>This feature is not enabled by default. To enable it, use the plug-in option <code>use_go_templates</code>.</p> <p>Additionally, you can define custom values and use them in your templates by utilizing the <code>go_template_args</code> option.</p>"},{"location":"reference/openapi/go_template/#where-can-you-use-templates","title":"Where Can You Use Templates?","text":"<p>You can incorporate Go Templates into various sections of your OpenAPI documentation:</p> <ul> <li>Title</li> <li>Summary</li> <li>Description</li> <li>External Docs Documentation</li> </ul> <p>You can define these templates in different contexts:</p> <ul> <li>Service</li> <li>Message</li> <li>Field</li> <li>Enum</li> <li>Method</li> </ul>"},{"location":"reference/openapi/go_template/#template-arguments","title":"Template Arguments","text":"<p>To effectively use templates, you need to understand the available arguments and how to incorporate them into your templates.</p>"},{"location":"reference/openapi/go_template/#functions","title":"Functions","text":"<p>There are some functions you can use in your Go Template.</p>"},{"location":"reference/openapi/go_template/#import","title":"Import","text":"<p>You can import another file and bring it in your documentation.</p> <pre><code>// Some existing text here.\n// {{ import \"user.tpl\" }}\nmessage User {\n  string name = 1;\n}\n</code></pre> <p>This function reads and evaluates the specified file as a Go template, replacing the second line with the resulting content.</p>"},{"location":"reference/openapi/go_template/#field-comments","title":"Field Comments","text":"<p>Field Comments can look up the documentation for a field.</p> <pre><code>// Some existing text here.\n// Name:\n//   * {{ fieldcomments index(.Fields 0) }}\nmessage User {\n  string name = 1;\n}\n</code></pre>"},{"location":"reference/openapi/go_template/#arg","title":"Arg","text":"<p>This function allows you to retrieve an argument provided via <code>go_template_args</code>.</p> <p>For instance, assuming we have used <code>go_template_args</code> with value <code>url=http://mydomain.com/</code></p> <pre><code>// Some existing text here.\n//\n// Read more about this type at {{ arg \"url\" }}/ref?name=User\nmessage User {\n  string name = 1;\n}\n</code></pre>"},{"location":"reference/openapi/go_template/#contexts","title":"Contexts","text":"<p>Go Templates can be used in different contexts. In each context, the variables are different and relevant to the context.</p>"},{"location":"reference/openapi/go_template/#enum","title":"Enum","text":"<p>Go template for enum will have the following fields:</p> Name Type Description File <code>File</code> The proto file that contains this enum. Name <code>string</code> Name of the enum. Value list of EnumVariant Slice of enum variants."},{"location":"reference/openapi/go_template/#enumvariant","title":"EnumVariant","text":"Name Type Description Name <code>string</code> Name of the enum value. Number <code>int32</code> Number of this enum value. <p>Example</p> <pre><code>// Subscription type holds multiple values:\n//\n// The following are accepted:\n// {{ range .Value }}\n// {{ .Name }} =&gt; {{ .Number }}\n// {{ end }}\nenum SubscriptionType {\n  SUBSCRIPTION_TYPE_UNSPECIFIED = 0;\n  SUBSCRIPTION_TYPE_PREMIUM = 1;\n  SUBSCRIPTION_TYPE_FREE = 2;\n}\n</code></pre>"},{"location":"reference/openapi/go_template/#message","title":"Message","text":"<p>Go template for message will have the following fields:</p> Name Type Description File <code>File</code> The proto file that contains this message. Name <code>string</code> Name of the message. Fields list of Field Slice of fields. <p>Example</p> <pre><code>// User is the user in the system.\n//\n// Following fields are available on the user:\n// {{ range .Fields }}\n// * {{ .Name }} (@ {{ .Number }}):\n//   {{ fieldcomments . }}\n// {{ end }}\nmessage User {\n  // Name is the full name of the user.\n  string name = 1;\n  // age is the age of this user.\n  string age = 2;\n}\n</code></pre>"},{"location":"reference/openapi/go_template/#field","title":"Field","text":"<p>Go template for field will have the following fields:</p> Name Type Description Name <code>string</code> Name of the enum value. Number <code>int32</code> The field tag number. TypeName <code>*string</code> The type name. JsonName <code>*string</code> The JSON name for this field. Proto3Optional <code>*bool</code> Whether or not this has proto3 optional label. Message Message The message that contains this field."},{"location":"reference/openapi/go_template/#service","title":"Service","text":"<p>Go template for service will have the following fields:</p> Name Type Description File <code>File</code> The proto file that contains this service. Name <code>string</code> Name of the enum value. Methods list of Method The RPC methods for this service."},{"location":"reference/openapi/go_template/#binding-openapi-operation","title":"Binding / OpenAPI Operation","text":"<p>Bindings are unique compared to other contexts because they are not native concepts in Protobuf. A binding defines the relationship between an HTTP endpoint and a gRPC method. Multiple HTTP endpoints can be mapped to the same gRPC method. Each endpoint in OpenAPI can have a <code>description</code> and a <code>summary</code>. By default, the summary is the first paragraph, and the description is the entire comment section for the corresponding method. However, this can be customized as needed.</p> <p>Thus, you can use the comment for each method, The Go Template however will have the Binding as its argument.</p> <p>Example</p> <pre><code>service BookService {\n  // Accepts: {{ .Method.RequestType.Name }}\n  // Returns: {{ .Method.ResponseType.Name }}\n  //\n  // Path: {{ .HTTPMethod }} {{ .PathTemplate }}\n  // Params:\n  // {{ range .PathParameters }}\n  //   - {{ .FieldPath }}\n  // {{ end }}\n  rpc UpdateBook(UpdateBookRequest) returns (UpdateBookResponse) {\n    option (meshapi.gateway.http) = {\n      put: \"/books/{id}\",\n      body: \"*\",\n      additional_bindings: [\n        {patch: \"/books/{id}\", body: \"*\"}\n      ]\n    }\n  };\n}\n</code></pre>"},{"location":"reference/openapi/go_template/#binding","title":"Binding","text":"Name Type Description Method Method gRPC Method for this binding. PathTemplate <code>string</code> PathTemplate HTTPMethod <code>string</code> HTTP Method (uppercase) PathParameters list of PathParameter The type name. QueryParameters list of QueryParameter The type name. Body Body Field path to the subfield that includes the body. ResponseBody Body Field path to the subfield that is the response body. StreamConfig StreamConfig Field path to the subfield that is the response body."},{"location":"reference/openapi/go_template/#pathparameter","title":"PathParameter","text":"Name Type Description FieldPath <code>string</code> Path to a proto field in the request message. Target Field Field related to this path parameter in the request message."},{"location":"reference/openapi/go_template/#queryparameter","title":"QueryParameter","text":"Name Type Description FieldPath <code>string</code> Path to a proto field in the request message. Name <code>string</code> Name of the query parameter. NameIsAlias <code>bool</code> Whether or not the name is an alias."},{"location":"reference/openapi/go_template/#body","title":"Body","text":"Name Type Description FieldPath <code>string</code> Path to a proto field in the request message."},{"location":"reference/openapi/go_template/#streamconfig","title":"StreamConfig","text":"Name Type Description AllowWebsocket <code>bool</code> Whether or not websocket is allowed for this binding. AllowSSE <code>bool</code> Whether or not Server-Sent-Events (SSE) is allowed for this binding. AllowChunkedTransfer <code>bool</code> Whether or not chunked transfer is allowed for this binding."},{"location":"reference/openapi/go_template/#method","title":"Method","text":"Name Type Description Name <code>string</code> Name of the enum value. Service Service The service containing this method. RequestType Message The request type. ResponseType Message The response type. ClientStreaming <code>*bool</code> Identifies if client streams multiple messages. ServerStreaming <code>*bool</code> Identifies if server streams multiple messages. Bindings lits of Binding List of bindings for this method."},{"location":"reference/openapi/operation_id/","title":"Operation IDs &amp; Service Tags","text":"<p>OpenAPI operations are defined within the paths of the API specification and represent the various endpoints that can be called. Each operation must have a unique operation ID, which serves as an identifier for that specific operation. This uniqueness is crucial as it allows for precise referencing and avoids conflicts within the API documentation and client code generation.</p> <p>Tags can also be assigned to operation objects to group them logically. These tags help in organizing the operations, making it easier to navigate and understand the API structure. Tags are typically used to categorize operations by their functionality or resource type, enhancing the readability and maintainability of the API documentation.</p>"},{"location":"reference/openapi/operation_id/#operation-ids","title":"Operation IDs","text":"<p>You have the flexibility to customize the format of automatically generated operation IDs using the OpenAPI plug-in, or you can choose to manually assign them for greater control and specificity.</p>"},{"location":"reference/openapi/operation_id/#manual-assignment","title":"Manual Assignment","text":"<p>Similar to many other configurations, you can use configuration files or directly set this in the proto file:</p> Proto AnnotationsConfiguration <pre><code>import \"meshapi/gateway/annotations.proto\";\n\nservice EchoService {\n  rpc Echo(EchoRequest) returns (EchoResponse) {\n    option (meshapi.gateway.openapi_operation) = {\n      operation_id: \"custom_operation_id\"\n    };\n  };\n}\n</code></pre> <pre><code>openapi:\n  services:\n    - selector: \"EchoService\"\n      methods:\n        Echo:\n          operation_id: \"custom_operation_id\"\n</code></pre>"},{"location":"reference/openapi/operation_id/#automatic-assignment","title":"Automatic Assignment","text":"<p>You can utilize the <code>operation_id_mode</code> plug-in option to define the format of the operation IDs.</p> <p>For instance, if you have a method named <code>Echo</code> within a service called <code>EchoService</code> in the package <code>meshapi.examples.echo.v1</code>, the following formats can be generated:</p> Operation ID Mode Operation Name <code>service+method</code> <code>EchoService_Echo</code> <code>method</code> <code>Echo</code> <code>fqn</code> <code>meshapi.examples.echo.v1.EchoService.Echo</code> <p>Info</p> <p>Multiple HTTP endpoints (operations) can be associated with a single gRPC method. In such cases, the additional bindings are appended with an incremental numerical suffix to distinguish them.</p> <p>Warning</p> <p>When using the <code>method</code> operation id mode, be aware that there is a potential risk of generating duplicate operation IDs if multiple services share the same gRPC method name.</p>"},{"location":"reference/openapi/operation_id/#tags","title":"Tags","text":"<p>By default, each operation is tagged with the service name, providing a clear and organized way to identify the operations. However, you have the option to override these tags to better categorize and group operations according to your specific needs. If you override the tags, this automatic generation will be skipped.</p> Proto AnnotationsConfiguration <pre><code>import \"meshapi/gateway/annotations.proto\";\n\nservice EchoService {\n  rpc Echo(EchoRequest) returns (EchoResponse) {\n    option (meshapi.gateway.openapi_operation) = {\n      tags: [\"tag1\", \"tag2\"]\n    };\n  };\n}\n</code></pre> <ol> <li>No automatic tag will be appended to this list.</li> </ol> <pre><code>openapi:\n  services:\n    - selector: \"EchoService\"\n      methods:\n        Echo:\n          tags:\n            - \"tag1\"\n            - \"tag2\"\n</code></pre>"},{"location":"reference/openapi/operation_id/#disable-automatic-service-tags","title":"Disable Automatic Service Tags","text":"<p>To prevent the automatic generation of tags based on the service name, use the <code>disable_service_tags</code> plug-in option.</p>"},{"location":"reference/openapi/operation_id/#include-package-name-in-tags","title":"Include Package Name in Tags","text":"<p>For services with identical names or if you prefer to include the full package name in the tags, utilize the <code>include_package_in_tags</code> option.</p>"},{"location":"reference/openapi/patch/","title":"Patch","text":""},{"location":"reference/openapi/patch/#introduction","title":"Introduction","text":"<p>The gRPC API Gateway patch feature allows you to update resources using HTTP PATCH requests. This is particularly useful for making partial updates to a resource without needing to send the entire resource representation. The PATCH feature can automatically generate a field mask that includes all the fields present in the request body.</p>"},{"location":"reference/openapi/patch/#why-is-using-an-update-mask-necessary","title":"Why is using an update mask necessary?","text":"<p>Without an update mask, null fields in the request body could either indicate that the API user wants to unset them or that they should remain unchanged. Using an update mask clarifies this ambiguity.</p>"},{"location":"reference/openapi/patch/#how-does-the-patch-feature-help-with-this","title":"How does the PATCH feature help with this?","text":"<p>The PATCH feature simplifies the update process by automatically generating a field mask based on the fields present in the request body. This ensures that only the specified fields are updated, reducing ambiguity and making partial updates more efficient.</p>"},{"location":"reference/openapi/patch/#how-to-use","title":"How to Use","text":""},{"location":"reference/openapi/patch/#1-define-update-mask","title":"1. Define Update Mask","text":"<p>In your proto request type, include a field named <code>update_mask</code> of type <code>google.protobuf.FieldMask</code>. This is crucial because the gateway requires this exact field name and type to populate them automatically.</p>"},{"location":"reference/openapi/patch/#2-define-patch-method-binding","title":"2. Define PATCH Method Binding","text":"<p>Only the <code>PATCH</code> HTTP method will trigger the automatic mapping of the field mask. Define the <code>PATCH</code> method in your Protobuf file or gateway configuration. While you can have additional bindings using other HTTP methods, the automatic mapping of the field mask will not occur with those methods.</p> <p>Another important aspect that is needed to enable the automatic population of the field mask is the <code>body</code> annotation. You must select the field subfield that contains the updates.</p>"},{"location":"reference/openapi/patch/#example","title":"Example","text":"<p>Below is an illustrative example demonstrating the use of the PATCH feature.</p> service.proto<pre><code>import \"meshapi/gateway/annotations.proto\";\nimport \"google/protobuf/field_mask.proto\";\n\nmessage Entity {\n  string id = 1;\n  string name = 2;\n}\n\nmessage Request {\n  Entity entity = 1;\n  google.protobuf.FieldMask update_mask = 2; // (1)!\n}\n\nmessage Response {}\n\nservice MyService {\n    rpc MyMethod(Request) returns (Response) {\n        option (meshapi.gateway.http) = {\n            patch: \"/my-endpoint/{entity.id}\",\n            body: \"entity\" // (2)!\n        };\n    }\n}\n</code></pre> <ol> <li>The update mask must be named <code>update_mask</code> to be recognized by the gateway.</li> <li>To enable automatic population of the <code>update_mask</code>, use the subfield that contains the partial updates, in this case, <code>entity</code>.</li> </ol> <p>Test the PATCH Endpoint</p> <p>Once you generate and implement your method, you can test the PATCH endpoint using tools like <code>curl</code> or Postman. Here is an example using <code>curl</code>.</p> <pre><code>curl -X PATCH -d '{\"name\": \"New Name\"}' http://localhost/my-endpoint/1\n</code></pre> <p>Notice that the <code>update_mask</code> is automatically set to <code>[\"name\"]</code>, indicating that the <code>\"name\"</code> field in the request body should be updated.</p> <p>Note</p> <p>The camelCase JSON name of the field is used to populate the update mask list.</p> <p>Note</p> <p>Only the values bound to the body annotation will appear in the update mask. For example, in the example above, the entity ID would not be included in the list.</p>"},{"location":"reference/openapi/patch/#best-practices","title":"Best Practices","text":"<ul> <li>Validation: Ensure that you validate the incoming data to prevent invalid updates.</li> <li>Partial Updates: Only update the fields that are provided in the request to avoid overwriting existing data.</li> <li>Error Handling: Implement proper error handling to return meaningful error messages to the client.</li> </ul> <p>By following these steps, you can effectively use the gRPC API Gateway patch feature to perform partial updates on your resources.</p>"},{"location":"reference/openapi/visibility/","title":"Visibility Selectors","text":""},{"location":"reference/openapi/visibility/#api-visibility-restrictions-in-grpc-and-protobuf","title":"API Visibility Restrictions in gRPC and Protobuf","text":"<p>When designing APIs with gRPC and Protobuf, it's important to manage the visibility of your services and messages to ensure proper access control and versioning. Here are some key points to consider:</p> <ul> <li>Public APIs: These are accessible to all clients and should be stable and well-documented. Public APIs are typically used for external integrations and third-party developers.</li> <li>Internal APIs: These are intended for use within your organization and can be more flexible in terms of changes. Internal APIs should still be documented but may not require the same level of stability as public APIs.</li> <li>Experimental APIs: These are used for testing new features and may change frequently. Experimental APIs should be clearly marked and should not be relied upon for production use.</li> </ul> <p>To enforce these visibility restrictions, you can use Protobuf options and annotations to specify the intended audience and stability level of your APIs.</p> <pre><code>import \"google/api/visibility.proto\";\n\nservice InternalService {\n  option (google.api.api_visibility).restriction = \"INTERNAL\";\n}\n\nservice Service {\n  rpc NewExperimentalMethod(Request) returns (Response) {\n    option (google.api.api_visibility).restriction = \"EXPERIMENTAL\";\n  };\n}\n</code></pre> <p>By default, all services and methods are considered. If the <code>visibility_selectors</code> plug-in option is left blank, visibility restrictions are ignored. However, you can provide a comma-separated list of labels to be considered. In this case, only the services and methods that either do not specify any visibility restriction or have at least one of the labels from the visibility selectors will be considered.</p>"}]}